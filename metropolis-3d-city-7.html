<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metropolis - 3D City Explorer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #87CEEB; font-family: system-ui, sans-serif; }
        #c { width: 100vw; height: 100vh; display: block; }
        
        #hud {
            position: fixed; top: 20px; left: 20px;
            color: #000; font-size: 14px; z-index: 100;
            background: rgba(255,255,255,0.8); padding: 10px 15px; border-radius: 8px;
            pointer-events: none;
        }
        #hud div { margin-bottom: 4px; }
        #hud .label { color: #666; font-size: 10px; }
        
        #weather { position: fixed; top: 20px; right: 20px; color: #333; font-size: 14px; z-index: 100; 
            background: rgba(255,255,255,0.8); padding: 8px 12px; border-radius: 8px; }
        
        #controls {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #333; font-size: 12px; text-align: center; z-index: 100;
            background: rgba(255,255,255,0.9); padding: 10px 20px; border-radius: 8px;
        }
        
        #minimap {
            position: fixed; bottom: 70px; right: 20px;
            width: 130px; height: 130px; border-radius: 50%;
            border: 3px solid rgba(0,100,200,0.6);
            background: rgba(200,230,255,0.9); z-index: 100; overflow: hidden;
        }
        #minimap canvas { width: 100%; height: 100%; }
        
        #loading {
            position: fixed; inset: 0; background: linear-gradient(135deg, #87CEEB, #4a90c2);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.8s;
        }
        #loading.done { opacity: 0; pointer-events: none; }
        #loading h1 { color: #fff; font-size: 42px; letter-spacing: 8px; margin-bottom: 25px; text-shadow: 2px 2px 10px rgba(0,0,0,0.3); }
        #bar { width: 280px; height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px; overflow: hidden; }
        #prog { width: 0%; height: 100%; background: #fff; transition: width 0.2s; }
        #ltxt { margin-top: 12px; color: #fff; font-size: 11px; letter-spacing: 2px; }
        
        #notif {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95); border: 2px solid #4a90c2; padding: 18px 35px;
            color: #333; font-size: 16px; z-index: 200; opacity: 0; transition: opacity 0.4s;
            text-align: center; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        #notif.show { opacity: 1; }
    </style>
</head>
<body>
    <div id="loading">
        <h1>METROPOLIS</h1>
        <div id="bar"><div id="prog"></div></div>
        <div id="ltxt">INITIALIZING...</div>
    </div>
    
    <canvas id="c"></canvas>
    
    <div id="hud">
        <div><span class="label">ALT</span> <span id="alt">0</span>m</div>
        <div><span class="label">SPD</span> <span id="spd">0</span>km/h</div>
        <div><span class="label">POS</span> <span id="pos">0,0</span></div>
    </div>
    
    <div id="weather">‚òÄÔ∏è Sunny 24¬∞C</div>
    <div id="minimap"><canvas id="mm"></canvas></div>
    <div id="controls">WASD: Move ‚Ä¢ Q/E: Up/Down ‚Ä¢ Mouse: Look ‚Ä¢ Scroll: Zoom ‚Ä¢ R: Rain ‚Ä¢ Space: Boost ‚Ä¢ Click to start</div>
    <div id="notif"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        
        const $ = id => document.getElementById(id);
        
        const GRID = {
            cellSize: 24,
            roadWidth: 8,
            sidewalkWidth: 2,
            gridCount: 4
        };
        
        const CFG = { cars: 25, emergencyVehicles: 3, peds: 50, bikes: 4 };
        
        let scene, cam, renderer, clock;
        let buildings = [], cars = [], emergencyVehicles = [], peds = [], tlights = [];
        let bicycles = [];
        let buildingEntrances = [];
        let allWindows = [];
        let billboards = [];
        let vel = null, baseSpd = 0.5, boost = false;
        let raining = false, rain = null;
        
        // Weather system
        let weatherState = 'sunny'; // 'sunny', 'cloudy', 'rain', 'storm'
        let weatherTimer = 0;
        let nextWeatherChange = 30 + Math.random() * 60; // First change in 30-90 seconds
        let stormDebris = [];
        let lightning = null;
        let lastLightning = 0;
        let windDirection = { x: 0, z: 0 };
        let windStrength = 0;
        let yaw = 0, pitch = -0.3, keys = {}, discoveries = new Set();
        let secrets = [], mmCtx;
        let lastWindowToggle = 0;
        let lastBikeSpawn = 0;
        let policeChaseTarget = null;
        
        // Gridlock detection system
        let lastGridlockCheck = 0;
        let trafficCop = null;
        let trafficCopTarget = null;
        
        // Special events system
        let specialEvent = null;
        let eventEntities = [];
        let lastEventCheck = 0;
        let eventCooldown = 0;
        
        // Garbage truck system
        let garbageTruck = null;
        let lastGarbageTruck = 0;
        let garbageTruckActive = false;
        let suctionActive = false;
        
        // Falling person system
        let fallingPerson = null;
        let fallenBody = null;
        let lastFallEvent = 0;
        let fallState = 'none'; // 'none', 'inWindow', 'falling', 'onGround', 'ambulancecoming', 'pickedup'
        let fallEventTimer = 0;
        let ambulanceForFallen = null;
        let flashingWindow = null;
        let flashCount = 0;
        
        let crosswalks = [];
        
        const totalSize = GRID.cellSize * GRID.gridCount;
        const halfSize = totalSize / 2;

        function prog(p, t) {
            $('prog').style.width = p + '%';
            $('ltxt').textContent = t.toUpperCase();
        }

        async function init() {
            prog(5, 'Creating universe...');

            vel = new THREE.Vector3();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 80, 350);
            
            cam = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 500);
            cam.position.set(0, 40, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas: $('c'), antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            clock = new THREE.Clock();
            
            prog(10, 'Lighting...');
            mkLighting();
            
            prog(20, 'City layout...');
            mkCityLayout();
            
            prog(50, 'Buildings...');
            mkBuildings();
            
            prog(60, 'Billboards...');
            mkBillboards();
            
            prog(70, 'Traffic system...');
            mkTrafficLights();
            mkCars();
            mkEmergencyVehicles();
            mkBuses();
            
            prog(80, 'Population...');
            mkPeds();
            mkBicycles();
            
            prog(90, 'Secrets...');
            mkSecrets();
            
            prog(98, 'Systems...');
            setupMM();
            setupInput();
            
            prog(100, 'Welcome');
            setTimeout(() => {
                $('loading').classList.add('done');
                notify('üåÜ Welcome to Metropolis<br>Click to look around!', 3500);
            }, 400);
            
            animate();
        }

        function mkLighting() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            
            const sun = new THREE.DirectionalLight(0xfffacd, 1.2);
            sun.position.set(80, 120, 60);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 10;
            sun.shadow.camera.far = 300;
            sun.shadow.camera.left = -120;
            sun.shadow.camera.right = 120;
            sun.shadow.camera.top = 120;
            sun.shadow.camera.bottom = -120;
            scene.add(sun);
            
            scene.add(new THREE.HemisphereLight(0x87CEEB, 0x3d5c3d, 0.5));
        }

        function mkCityLayout() {
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(totalSize + 50, totalSize + 50),
                new THREE.MeshStandardMaterial({ color: 0x4a6a4a, roughness: 0.9 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);
            
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
            const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.8 });
            const lineMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            for (let i = 0; i <= GRID.gridCount; i++) {
                const pos = -halfSize + i * GRID.cellSize;
                
                const hRoad = new THREE.Mesh(new THREE.PlaneGeometry(totalSize + 10, GRID.roadWidth), roadMat);
                hRoad.rotation.x = -Math.PI / 2;
                hRoad.position.set(0, 0.01, pos);
                scene.add(hRoad);
                
                const vRoad = new THREE.Mesh(new THREE.PlaneGeometry(GRID.roadWidth, totalSize + 10), roadMat);
                vRoad.rotation.x = -Math.PI / 2;
                vRoad.position.set(pos, 0.01, 0);
                scene.add(vRoad);
                
                for (let j = 0; j < GRID.gridCount; j++) {
                    const segStart = -halfSize + j * GRID.cellSize + GRID.roadWidth / 2 + 2;
                    const segEnd = -halfSize + (j + 1) * GRID.cellSize - GRID.roadWidth / 2 - 2;
                    
                    for (let k = segStart; k < segEnd; k += 5) {
                        const hLine = new THREE.Mesh(new THREE.PlaneGeometry(3, 0.2), lineMat);
                        hLine.rotation.x = -Math.PI / 2;
                        hLine.position.set(k + 1.5, 0.02, pos);
                        scene.add(hLine);
                        
                        const vLine = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 3), lineMat);
                        vLine.rotation.x = -Math.PI / 2;
                        vLine.position.set(pos, 0.02, k + 1.5);
                        scene.add(vLine);
                    }
                }
            }
            
            for (let bx = 0; bx < GRID.gridCount; bx++) {
                for (let bz = 0; bz < GRID.gridCount; bz++) {
                    const blockCenterX = -halfSize + bx * GRID.cellSize + GRID.cellSize / 2;
                    const blockCenterZ = -halfSize + bz * GRID.cellSize + GRID.cellSize / 2;
                    const innerSize = GRID.cellSize - GRID.roadWidth;
                    const swDepth = GRID.sidewalkWidth;
                    
                    const nSw = new THREE.Mesh(new THREE.BoxGeometry(innerSize, 0.15, swDepth), sidewalkMat);
                    nSw.position.set(blockCenterX, 0.075, blockCenterZ - innerSize/2 + swDepth/2);
                    scene.add(nSw);
                    
                    const sSw = new THREE.Mesh(new THREE.BoxGeometry(innerSize, 0.15, swDepth), sidewalkMat);
                    sSw.position.set(blockCenterX, 0.075, blockCenterZ + innerSize/2 - swDepth/2);
                    scene.add(sSw);
                    
                    const wSw = new THREE.Mesh(new THREE.BoxGeometry(swDepth, 0.15, innerSize - swDepth * 2), sidewalkMat);
                    wSw.position.set(blockCenterX - innerSize/2 + swDepth/2, 0.075, blockCenterZ);
                    scene.add(wSw);
                    
                    const eSw = new THREE.Mesh(new THREE.BoxGeometry(swDepth, 0.15, innerSize - swDepth * 2), sidewalkMat);
                    eSw.position.set(blockCenterX + innerSize/2 - swDepth/2, 0.075, blockCenterZ);
                    scene.add(eSw);
                }
            }
            
            for (let i = 0; i <= GRID.gridCount; i++) {
                for (let j = 0; j <= GRID.gridCount; j++) {
                    const ix = -halfSize + i * GRID.cellSize;
                    const iz = -halfSize + j * GRID.cellSize;
                    
                    if (i < GRID.gridCount) {
                        const cwX = ix + GRID.roadWidth / 2 + 3;
                        for (let s = 0; s < 6; s++) {
                            const stripe = new THREE.Mesh(new THREE.PlaneGeometry(3, 0.5), whiteMat);
                            stripe.rotation.x = -Math.PI / 2;
                            stripe.position.set(cwX, 0.02, iz - GRID.roadWidth/2 + 1.5 + s * 1);
                            scene.add(stripe);
                        }
                        crosswalks.push({ x: cwX, z: iz, axis: 'z', width: GRID.roadWidth });
                    }
                    
                    if (j < GRID.gridCount) {
                        const cwZ = iz + GRID.roadWidth / 2 + 3;
                        for (let s = 0; s < 6; s++) {
                            const stripe = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 3), whiteMat);
                            stripe.rotation.x = -Math.PI / 2;
                            stripe.position.set(ix - GRID.roadWidth/2 + 1.5 + s * 1, 0.02, cwZ);
                            scene.add(stripe);
                        }
                        crosswalks.push({ x: ix, z: cwZ, axis: 'x', width: GRID.roadWidth });
                    }
                }
            }
        }

        function mkBuildings() {
            const innerSize = GRID.cellSize - GRID.roadWidth - GRID.sidewalkWidth * 2;
            const types = [
                { minH: 18, maxH: 65, col: 0x8899aa },
                { minH: 12, maxH: 45, col: 0x99aabb },
                { minH: 28, maxH: 85, col: 0x7788aa },
                { minH: 10, maxH: 30, col: 0xaabbcc }
            ];
            
            for (let bx = 0; bx < GRID.gridCount; bx++) {
                for (let bz = 0; bz < GRID.gridCount; bz++) {
                    const blockCenterX = -halfSize + bx * GRID.cellSize + GRID.cellSize / 2;
                    const blockCenterZ = -halfSize + bz * GRID.cellSize + GRID.cellSize / 2;
                    const numBuildings = 1 + Math.floor(Math.random() * 2);
                    
                    for (let i = 0; i < numBuildings; i++) {
                        const t = types[Math.floor(Math.random() * types.length)];
                        const h = t.minH + Math.random() * (t.maxH - t.minH);
                        const maxW = (innerSize - 2) / numBuildings;
                        const w = Math.min(maxW, 5 + Math.random() * 7);
                        const d = Math.min(innerSize - 4, 5 + Math.random() * 7);
                        
                        const b = mkBuilding(w, h, d, t.col);
                        const offsetX = numBuildings > 1 ? (i - 0.5) * (innerSize / 2) : 0;
                        b.position.set(blockCenterX + offsetX, 0, blockCenterZ);
                        b.userData.height = h;
                        b.userData.width = w;
                        b.userData.depth = d;
                        
                        // Store global entrance positions
                        b.userData.entrances.forEach(ent => {
                            buildingEntrances.push({
                                x: b.position.x + ent.localX,
                                z: b.position.z + ent.localZ,
                                side: ent.side,
                                building: b
                            });
                        });
                        
                        buildings.push(b);
                        scene.add(b);
                    }
                }
            }
        }

        function mkBuilding(w, h, d, col) {
            const g = new THREE.Group();
            
            const mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.7, metalness: 0.1 });
            const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            m.position.y = h / 2;
            m.castShadow = true;
            m.receiveShadow = true;
            g.add(m);
            
            // Add entrance doors (1-2 per building)
            const numEntrances = 1 + Math.floor(Math.random() * 2);
            const sides = [0, 1, 2, 3].sort(() => Math.random() - 0.5).slice(0, numEntrances);
            g.userData.entrances = [];
            
            sides.forEach(side => {
                const doorMat = new THREE.MeshStandardMaterial({ color: 0x553322 });
                const door = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.5, 0.1), doorMat);
                const frameMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
                const frame = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.8, 0.05), frameMat);
                
                let entrancePos = { x: 0, z: 0, side: side };
                
                if (side === 0) { // Front (positive Z)
                    door.position.set(0, 1.25, d/2 + 0.05);
                    frame.position.set(0, 1.4, d/2 + 0.02);
                    entrancePos.localX = 0;
                    entrancePos.localZ = d/2 + 0.5;
                } else if (side === 1) { // Back (negative Z)
                    door.position.set(0, 1.25, -d/2 - 0.05);
                    door.rotation.y = Math.PI;
                    frame.position.set(0, 1.4, -d/2 - 0.02);
                    entrancePos.localX = 0;
                    entrancePos.localZ = -d/2 - 0.5;
                } else if (side === 2) { // Right (positive X)
                    door.position.set(w/2 + 0.05, 1.25, 0);
                    door.rotation.y = Math.PI / 2;
                    frame.position.set(w/2 + 0.02, 1.4, 0);
                    frame.rotation.y = Math.PI / 2;
                    entrancePos.localX = w/2 + 0.5;
                    entrancePos.localZ = 0;
                } else { // Left (negative X)
                    door.position.set(-w/2 - 0.05, 1.25, 0);
                    door.rotation.y = -Math.PI / 2;
                    frame.position.set(-w/2 - 0.02, 1.4, 0);
                    frame.rotation.y = Math.PI / 2;
                    entrancePos.localX = -w/2 - 0.5;
                    entrancePos.localZ = 0;
                }
                
                g.add(door);
                g.add(frame);
                g.userData.entrances.push(entrancePos);
            });
            
            const rows = Math.floor(h / 3.5);
            const colsW = Math.max(1, Math.floor(w / 2.2));
            const colsD = Math.max(1, Math.floor(d / 2.2));
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < colsW; c++) {
                    const xPos = colsW > 1 ? -w/2 + 1.1 + c * ((w - 2.2) / (colsW - 1)) : 0;
                    
                    const isLit1 = Math.random() > 0.3;
                    const wf = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.9, 1.4),
                        new THREE.MeshBasicMaterial({ color: isLit1 ? 0xffeeaa : 0x334455 })
                    );
                    wf.position.set(xPos, 3 + r * 3.5, d/2 + 0.01);
                    wf.userData.isLit = isLit1;
                    allWindows.push(wf);
                    g.add(wf);
                    
                    const isLit2 = Math.random() > 0.3;
                    const wb = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.9, 1.4),
                        new THREE.MeshBasicMaterial({ color: isLit2 ? 0xffeeaa : 0x334455 })
                    );
                    wb.position.set(xPos, 3 + r * 3.5, -d/2 - 0.01);
                    wb.rotation.y = Math.PI;
                    wb.userData.isLit = isLit2;
                    allWindows.push(wb);
                    g.add(wb);
                }
                
                for (let c = 0; c < colsD; c++) {
                    const zPos = colsD > 1 ? -d/2 + 1.1 + c * ((d - 2.2) / (colsD - 1)) : 0;
                    
                    const isLit3 = Math.random() > 0.3;
                    const wr = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.9, 1.4),
                        new THREE.MeshBasicMaterial({ color: isLit3 ? 0xffeeaa : 0x334455 })
                    );
                    wr.position.set(w/2 + 0.01, 3 + r * 3.5, zPos);
                    wr.rotation.y = Math.PI / 2;
                    wr.userData.isLit = isLit3;
                    allWindows.push(wr);
                    g.add(wr);
                    
                    const isLit4 = Math.random() > 0.3;
                    const wl = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.9, 1.4),
                        new THREE.MeshBasicMaterial({ color: isLit4 ? 0xffeeaa : 0x334455 })
                    );
                    wl.position.set(-w/2 - 0.01, 3 + r * 3.5, zPos);
                    wl.rotation.y = -Math.PI / 2;
                    wl.userData.isLit = isLit4;
                    allWindows.push(wl);
                    g.add(wl);
                }
            }
            
            if (h > 40) {
                const antenna = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12, 0.12, 8),
                    new THREE.MeshStandardMaterial({ color: 0x666666 })
                );
                antenna.position.y = h + 4;
                g.add(antenna);
            }
            
            return g;
        }

        function mkBillboards() {
            const tallBuildings = buildings.filter(b => b.userData.height > 45);
            const selected = tallBuildings.sort(() => Math.random() - 0.5).slice(0, 3);
            
            const brands = [
                { name: 'Drink Cola', bg: 0xcc0000, text: 0xffffff },
                { name: 'Be Happy', bg: 0x0066cc, text: 0xffff00 },
                { name: 'OBEY!', bg: 0x111111, text: 0xff0000 }
            ];
            
            selected.forEach((building, idx) => {
                const brand = brands[idx % brands.length];
                const h = building.userData.height;
                
                const billboard = new THREE.Group();
                
                // Support poles - attached to building roof
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
                const pole1 = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 5), poleMat);
                pole1.position.set(-2.5, 2.5, 0);
                billboard.add(pole1);
                const pole2 = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 5), poleMat);
                pole2.position.set(2.5, 2.5, 0);
                billboard.add(pole2);
                
                // Sign background
                const signBg = new THREE.Mesh(
                    new THREE.BoxGeometry(7, 3.5, 0.3),
                    new THREE.MeshStandardMaterial({ color: brand.bg })
                );
                signBg.position.y = 5.5;
                billboard.add(signBg);
                
                // Animated light border
                const borderMat = new THREE.MeshBasicMaterial({ color: brand.text });
                for (let i = 0; i < 16; i++) {
                    const light = new THREE.Mesh(new THREE.SphereGeometry(0.1), borderMat.clone());
                    const angle = (i / 16) * Math.PI * 2;
                    const x = Math.cos(angle) * 3.2;
                    const y = Math.sin(angle) * 1.5 + 5.5;
                    light.position.set(x, y, 0.2);
                    light.userData.lightIndex = i;
                    light.userData.isBillboardLight = true;
                    billboard.add(light);
                }
                
                // Create actual text using canvas texture
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Background
                ctx.fillStyle = brand.bg === 0xcc0000 ? '#cc0000' : brand.bg === 0x0066cc ? '#0066cc' : '#111111';
                ctx.fillRect(0, 0, 512, 256);
                
                // Text
                ctx.fillStyle = brand.text === 0xffffff ? '#ffffff' : brand.text === 0xffff00 ? '#ffff00' : '#ff0000';
                ctx.font = 'bold 64px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(brand.name, 256, 128);
                
                const texture = new THREE.CanvasTexture(canvas);
                const textPlane = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, 3),
                    new THREE.MeshBasicMaterial({ map: texture })
                );
                textPlane.position.set(0, 5.5, 0.2);
                billboard.add(textPlane);
                
                // Back side text
                const textPlaneBack = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, 3),
                    new THREE.MeshBasicMaterial({ map: texture })
                );
                textPlaneBack.position.set(0, 5.5, -0.2);
                textPlaneBack.rotation.y = Math.PI;
                billboard.add(textPlaneBack);
                
                // Neon glow effect
                const glowMat = new THREE.MeshBasicMaterial({ 
                    color: brand.text, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const glow = new THREE.Mesh(new THREE.PlaneGeometry(6.5, 3.5), glowMat);
                glow.position.set(0, 5.5, 0.25);
                glow.userData.isGlow = true;
                billboard.add(glow);
                
                // Position billboard centered on building roof
                billboard.position.set(building.position.x, h, building.position.z);
                billboard.userData.brand = brand;
                billboards.push(billboard);
                scene.add(billboard);
            });

            // Add PAY TAXES flashing sign
            const taxBuildings = tallBuildings.filter(b => !selected.includes(b));
            if (taxBuildings.length > 0) {
                const taxBuilding = taxBuildings[Math.floor(Math.random() * taxBuildings.length)];
                const h = taxBuilding.userData.height;

                const taxSign = new THREE.Group();

                // Support poles
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
                const pole1 = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 5), poleMat);
                pole1.position.set(-3, 2.5, 0);
                taxSign.add(pole1);
                const pole2 = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 5), poleMat);
                pole2.position.set(3, 2.5, 0);
                taxSign.add(pole2);

                // Sign background - black
                const signBg = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 4, 0.3),
                    new THREE.MeshStandardMaterial({ color: 0x111111 })
                );
                signBg.position.y = 5.5;
                taxSign.add(signBg);

                // Create flashing text planes (one on, one off)
                const createTaxTexture = (textColor) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#111111';
                    ctx.fillRect(0, 0, 512, 256);
                    ctx.fillStyle = textColor;
                    ctx.font = 'bold 72px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('PAY TAXES', 256, 128);
                    return new THREE.CanvasTexture(canvas);
                };

                const textureOn = createTaxTexture('#00ff00');
                const textureOff = createTaxTexture('#003300');

                const textPlaneOn = new THREE.Mesh(
                    new THREE.PlaneGeometry(7, 3.5),
                    new THREE.MeshBasicMaterial({ map: textureOn })
                );
                textPlaneOn.position.set(0, 5.5, 0.2);
                textPlaneOn.userData.isTaxSign = true;
                taxSign.add(textPlaneOn);

                const textPlaneOff = new THREE.Mesh(
                    new THREE.PlaneGeometry(7, 3.5),
                    new THREE.MeshBasicMaterial({ map: textureOff })
                );
                textPlaneOff.position.set(0, 5.5, 0.2);
                textPlaneOff.visible = false;
                textPlaneOff.userData.isTaxSignOff = true;
                taxSign.add(textPlaneOff);

                // Back side
                const textPlaneOnBack = new THREE.Mesh(
                    new THREE.PlaneGeometry(7, 3.5),
                    new THREE.MeshBasicMaterial({ map: textureOn })
                );
                textPlaneOnBack.position.set(0, 5.5, -0.2);
                textPlaneOnBack.rotation.y = Math.PI;
                textPlaneOnBack.userData.isTaxSign = true;
                taxSign.add(textPlaneOnBack);

                const textPlaneOffBack = new THREE.Mesh(
                    new THREE.PlaneGeometry(7, 3.5),
                    new THREE.MeshBasicMaterial({ map: textureOff })
                );
                textPlaneOffBack.position.set(0, 5.5, -0.2);
                textPlaneOffBack.rotation.y = Math.PI;
                textPlaneOffBack.visible = false;
                textPlaneOffBack.userData.isTaxSignOff = true;
                taxSign.add(textPlaneOffBack);

                taxSign.position.set(taxBuilding.position.x, h, taxBuilding.position.z);
                taxSign.userData.isTaxBillboard = true;
                billboards.push(taxSign);
                scene.add(taxSign);
            }
        }

        function mkTrafficLights() {
            for (let i = 1; i < GRID.gridCount; i++) {
                for (let j = 1; j < GRID.gridCount; j++) {
                    const ix = -halfSize + i * GRID.cellSize;
                    const iz = -halfSize + j * GRID.cellSize;
                    
                    const tl = mkTL();
                    tl.position.set(ix + GRID.roadWidth/2 - 0.5, 0, iz + GRID.roadWidth/2 - 0.5);
                    tl.userData.phase = Math.random() * Math.PI * 2;
                    tl.userData.intersection = { x: ix, z: iz };
                    tlights.push(tl);
                    scene.add(tl);
                }
            }
        }

        function mkTL() {
            const g = new THREE.Group();
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            
            // Main pole
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 7), poleMat);
            pole.position.y = 3.5;
            g.add(pole);
            
            // Cross arms for 4-way signals
            const armLength = 2.5;
            const armHeight = 7;
            
            // Horizontal arm (X direction)
            const armX = new THREE.Mesh(new THREE.BoxGeometry(armLength * 2, 0.15, 0.15), poleMat);
            armX.position.set(0, armHeight, 0);
            g.add(armX);
            
            // Horizontal arm (Z direction)
            const armZ = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, armLength * 2), poleMat);
            armZ.position.set(0, armHeight, 0);
            g.add(armZ);
            
            const lts = [];
            const cols = [0xff0000, 0xffff00, 0x00ff00];
            
            // Create signal boxes on all 4 sides
            // Each side has 3 lights (red, yellow, green from top to bottom)
            const sides = [
                { x: armLength, z: 0, rotY: -Math.PI / 2, axis: 'x', dir: 1 },    // East-facing (for westbound traffic)
                { x: -armLength, z: 0, rotY: Math.PI / 2, axis: 'x', dir: -1 },   // West-facing (for eastbound traffic)
                { x: 0, z: armLength, rotY: Math.PI, axis: 'z', dir: 1 },         // South-facing (for northbound traffic)
                { x: 0, z: -armLength, rotY: 0, axis: 'z', dir: -1 }              // North-facing (for southbound traffic)
            ];
            
            sides.forEach(side => {
                // Signal box
                const box = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.4, 0.3), poleMat);
                box.position.set(side.x, armHeight - 0.2, side.z);
                box.rotation.y = side.rotY;
                g.add(box);
                
                // Three lights
                cols.forEach((c, i) => {
                    const light = new THREE.Mesh(
                        new THREE.SphereGeometry(0.12),
                        new THREE.MeshBasicMaterial({ color: 0x222222 })
                    );
                    
                    // Position light on front face of box
                    const offsetX = Math.sin(side.rotY) * 0.16;
                    const offsetZ = Math.cos(side.rotY) * 0.16;
                    light.position.set(
                        side.x + offsetX,
                        armHeight + 0.3 - i * 0.4,
                        side.z + offsetZ
                    );
                    
                    light.userData.activeCol = c;
                    light.userData.axis = side.axis;  // Which road this light controls
                    light.userData.lightIndex = i;    // 0=red, 1=yellow, 2=green
                    lts.push(light);
                    g.add(light);
                });
            });
            
            g.userData.lts = lts;
            return g;
        }

        function mkCars() {
            const cols = [0xff3333, 0x3366ff, 0xffcc00, 0x33cc33, 0xff66cc, 0xeeeeee, 0x222222, 0xff6600, 0x00cccc];
            
            for (let i = 0; i < CFG.cars; i++) {
                const car = mkCar(cols[Math.floor(Math.random() * cols.length)]);
                placeCarOnRoad(car);
                car.userData.isEmergency = false;
                cars.push(car);
                scene.add(car);
            }
        }

        function mkEmergencyVehicles() {
            // Police car
            const police = mkCar(0x000033);
            police.userData.isEmergency = true;
            police.userData.emergencyType = 'police';
            addEmergencyLights(police, 0x0000ff, 0xff0000);
            placeCarOnRoad(police);
            emergencyVehicles.push(police);
            cars.push(police);
            scene.add(police);
            
            // Fire truck
            const fire = mkCar(0xcc0000);
            fire.userData.isEmergency = true;
            fire.userData.emergencyType = 'fire';
            addEmergencyLights(fire, 0xff0000, 0xff0000);
            placeCarOnRoad(fire);
            emergencyVehicles.push(fire);
            cars.push(fire);
            scene.add(fire);
            
            // Ambulance
            const ambulance = mkCar(0xffffff);
            ambulance.userData.isEmergency = true;
            ambulance.userData.emergencyType = 'ambulance';
            addEmergencyLights(ambulance, 0xff0000, 0xffffff);
            placeCarOnRoad(ambulance);
            emergencyVehicles.push(ambulance);
            cars.push(ambulance);
            scene.add(ambulance);
        }

        function mkBuses() {
            // Create 2 double-decker tourist buses
            for (let i = 0; i < 2; i++) {
                const bus = mkDoubleDecker();
                placeCarOnRoad(bus);
                bus.userData.isBus = true;
                bus.userData.busType = 'tourist';
                bus.userData.spd = 0.08 + Math.random() * 0.02; // Slower than cars
                cars.push(bus);
                scene.add(bus);
            }
            
            // Create 3 jitney buses
            for (let i = 0; i < 3; i++) {
                const jitney = mkJitney();
                placeCarOnRoad(jitney);
                jitney.userData.isBus = true;
                jitney.userData.busType = 'jitney';
                jitney.userData.spd = 0.10 + Math.random() * 0.03; // Slightly faster, more erratic
                cars.push(jitney);
                scene.add(jitney);
            }
            
            // Create omnibus line
            createOmnibusLine();
        }
        
        let omnibus = null;
        let omnibusStops = [];
        let omnibusPassengers = [];
        const OMNIBUS_MAX_PASSENGERS = 8;
        
        function createOmnibusLine() {
            // Create bus stops around the city center (inner loop)
            const innerRoad1 = -halfSize + 1 * GRID.cellSize; // First inner road
            const innerRoad2 = -halfSize + 2 * GRID.cellSize; // Second inner road
            const innerRoad3 = -halfSize + 3 * GRID.cellSize; // Third inner road
            
            // Bus stops at corners of inner blocks - forms a square route
            omnibusStops = [
                { x: innerRoad1 + 3, z: innerRoad1, dir: 'east', axis: 'x' },
                { x: innerRoad3, z: innerRoad1 + 3, dir: 'south', axis: 'z' },
                { x: innerRoad3 - 3, z: innerRoad3, dir: 'west', axis: 'x' },
                { x: innerRoad1, z: innerRoad3 - 3, dir: 'north', axis: 'z' }
            ];
            
            // Create bus stop signs
            omnibusStops.forEach((stop, i) => {
                const stopSign = mkBusStop(i + 1);
                stopSign.position.set(stop.x, 0, stop.z);
                scene.add(stopSign);
                stop.sign = stopSign;
                stop.waitingPeds = [];
            });
            
            // Create the omnibus
            omnibus = mkOmnibus();
            omnibus.position.set(omnibusStops[0].x, 0, omnibusStops[0].z);
            omnibus.userData.currentStop = 0;
            omnibus.userData.nextStop = 1;
            omnibus.userData.state = 'moving'; // 'moving', 'stopping', 'boarding'
            omnibus.userData.stopTimer = 0;
            omnibus.userData.spd = 0.07;
            scene.add(omnibus);
            
            notify('üöå Omnibus Line 1 now running!', 3000);
        }
        
        function mkBusStop(number) {
            const g = new THREE.Group();
            
            // Pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 2.5, 8),
                new THREE.MeshStandardMaterial({ color: 0x228822 })
            );
            pole.position.y = 1.25;
            g.add(pole);
            
            // Sign
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.6, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x22aa22 })
            );
            sign.position.y = 2.3;
            g.add(sign);
            
            // "BUS" text (simple box representation)
            const textBg = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.3, 0.02),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            textBg.position.set(0, 2.35, 0.06);
            g.add(textBg);
            
            // Stop number
            const numSign = new THREE.Mesh(
                new THREE.CircleGeometry(0.15, 16),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            );
            numSign.position.set(0, 2.1, 0.06);
            g.add(numSign);
            
            // Bench
            const bench = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.1, 0.4),
                new THREE.MeshStandardMaterial({ color: 0x885533 })
            );
            bench.position.set(0.8, 0.4, 0);
            g.add(bench);
            
            const benchLegs = new THREE.Mesh(
                new THREE.BoxGeometry(1.0, 0.4, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x664422 })
            );
            benchLegs.position.set(0.8, 0.2, 0);
            g.add(benchLegs);
            
            return g;
        }
        
        function mkOmnibus() {
            const g = new THREE.Group();
            
            // Vintage omnibus body - cream/green livery
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(3.8, 1.4, 1.6),
                new THREE.MeshStandardMaterial({ color: 0xf5f5dc, metalness: 0.2, roughness: 0.7 }) // Cream
            );
            body.position.y = 1.0;
            body.castShadow = true;
            g.add(body);
            
            // Green stripe along bottom
            const stripe = new THREE.Mesh(
                new THREE.BoxGeometry(3.85, 0.3, 1.65),
                new THREE.MeshStandardMaterial({ color: 0x228833 })
            );
            stripe.position.y = 0.5;
            g.add(stripe);
            
            // Roof - rounded look with green
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(3.6, 0.25, 1.4),
                new THREE.MeshStandardMaterial({ color: 0x228833 })
            );
            roof.position.y = 1.85;
            g.add(roof);
            
            // Destination sign on front
            const destSign = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.35, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x111111 })
            );
            destSign.position.set(1.5, 1.6, 0);
            destSign.rotation.y = Math.PI / 2;
            g.add(destSign);
            
            // "LINE 1" text background
            const lineText = new THREE.Mesh(
                new THREE.BoxGeometry(1.0, 0.25, 0.02),
                new THREE.MeshBasicMaterial({ color: 0xffaa00 })
            );
            lineText.position.set(1.53, 1.6, 0);
            lineText.rotation.y = Math.PI / 2;
            g.add(lineText);
            
            // Windows (5 on each side)
            const winMat = new THREE.MeshBasicMaterial({ color: 0x88ccff });
            for (let i = 0; i < 5; i++) {
                const win = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.5), winMat);
                win.position.set(-1.2 + i * 0.7, 1.2, 0.81);
                g.add(win);
                const win2 = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.5), winMat);
                win2.position.set(-1.2 + i * 0.7, 1.2, -0.81);
                win2.rotation.y = Math.PI;
                g.add(win2);
            }
            
            // Front windshield
            const windshield = new THREE.Mesh(
                new THREE.PlaneGeometry(1.3, 0.7),
                winMat
            );
            windshield.position.set(1.91, 1.1, 0);
            windshield.rotation.y = Math.PI / 2;
            g.add(windshield);
            
            // Headlights (cute round ones)
            const hlMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
            [-0.5, 0.5].forEach(z => {
                const hl = new THREE.Mesh(new THREE.CircleGeometry(0.12, 12), hlMat);
                hl.position.set(1.91, 0.6, z);
                hl.rotation.y = Math.PI / 2;
                g.add(hl);
            });
            
            // Wheels (6 wheels)
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const wheelPositions = [
                [1.3, 0.25, 0.85], [1.3, 0.25, -0.85],
                [-0.5, 0.25, 0.85], [-0.5, 0.25, -0.85],
                [-1.3, 0.25, 0.85], [-1.3, 0.25, -0.85]
            ];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.15, 16), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...pos);
                g.add(wheel);
            });
            
            // Bell on top (for cute factor!)
            const bell = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0xddaa00, metalness: 0.8 })
            );
            bell.position.set(1.2, 2.05, 0);
            g.add(bell);
            g.userData.bell = bell;
            
            // Passenger indicators (colored dots on roof)
            g.userData.passengerDots = [];
            for (let i = 0; i < OMNIBUS_MAX_PASSENGERS; i++) {
                const dot = new THREE.Mesh(
                    new THREE.CircleGeometry(0.1, 8),
                    new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.3 })
                );
                dot.position.set(-1.0 + (i % 4) * 0.5, 1.98, -0.4 + Math.floor(i / 4) * 0.8);
                dot.rotation.x = -Math.PI / 2;
                g.add(dot);
                g.userData.passengerDots.push(dot);
            }
            
            return g;
        }
        
        function updOmnibus(t) {
            if (!omnibus) return;
            
            const currentStop = omnibusStops[omnibus.userData.currentStop];
            const nextStop = omnibusStops[omnibus.userData.nextStop];
            
            // Ring bell occasionally
            if (omnibus.userData.bell && Math.random() < 0.002) {
                omnibus.userData.bell.scale.setScalar(1.3);
                setTimeout(() => {
                    if (omnibus.userData.bell) omnibus.userData.bell.scale.setScalar(1);
                }, 100);
            }
            
            if (omnibus.userData.state === 'moving') {
                // Move toward next stop
                const dx = nextStop.x - omnibus.position.x;
                const dz = nextStop.z - omnibus.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < 1) {
                    // Arrived at stop
                    omnibus.userData.state = 'stopping';
                    omnibus.userData.stopTimer = 0;
                    omnibus.position.set(nextStop.x, 0, nextStop.z);
                } else {
                    // Check for obstacles ahead
                    let omnibusBlocked = false;
                    
                    // Check cars
                    for (const car of cars) {
                        const cdx = car.position.x - omnibus.position.x;
                        const cdz = car.position.z - omnibus.position.z;
                        const cdist = Math.sqrt(cdx * cdx + cdz * cdz);
                        // Check if car is in our path
                        const dotProduct = (cdx * dx + cdz * dz) / dist;
                        if (dotProduct > 0 && cdist < 5) {
                            omnibusBlocked = true;
                            break;
                        }
                    }
                    
                    // Check garbage truck
                    if (!omnibusBlocked && garbageTruck && garbageTruckActive) {
                        const gdx = garbageTruck.position.x - omnibus.position.x;
                        const gdz = garbageTruck.position.z - omnibus.position.z;
                        const gdist = Math.sqrt(gdx * gdx + gdz * gdz);
                        if (gdist < 8) {
                            omnibusBlocked = true;
                        }
                    }
                    
                    // Check pedestrians
                    for (const ped of peds) {
                        if (!ped.visible) continue;
                        const pdx = ped.position.x - omnibus.position.x;
                        const pdz = ped.position.z - omnibus.position.z;
                        const pdist = Math.sqrt(pdx * pdx + pdz * pdz);
                        const dotProduct = (pdx * dx + pdz * dz) / dist;
                        if (dotProduct > 0 && pdist < 6) {
                            omnibusBlocked = true;
                            break;
                        }
                    }
                    
                    if (!omnibusBlocked) {
                        // Keep moving
                        const speed = omnibus.userData.spd;
                        omnibus.position.x += (dx / dist) * speed;
                        omnibus.position.z += (dz / dist) * speed;

                        // Face direction of travel (front of bus is +X, so subtract PI/2)
                        omnibus.rotation.y = Math.atan2(dx, dz) - Math.PI / 2;
                    }
                }
            } else if (omnibus.userData.state === 'stopping') {
                omnibus.userData.stopTimer += 0.016;
                
                if (omnibus.userData.stopTimer > 0.5) {
                    omnibus.userData.state = 'boarding';
                    omnibus.userData.stopTimer = 0;
                    
                    // Let passengers off
                    const numOff = Math.min(omnibusPassengers.length, Math.floor(Math.random() * 3));
                    for (let i = 0; i < numOff; i++) {
                        disembarkPassenger(nextStop);
                    }
                    
                    // Board waiting passengers
                    const stop = nextStop;
                    const numBoard = Math.min(
                        stop.waitingPeds.length,
                        OMNIBUS_MAX_PASSENGERS - omnibusPassengers.length,
                        Math.floor(Math.random() * 3) + 1
                    );
                    for (let i = 0; i < numBoard; i++) {
                        boardPassenger(stop);
                    }
                    
                    updatePassengerDots();
                }
            } else if (omnibus.userData.state === 'boarding') {
                omnibus.userData.stopTimer += 0.016;
                
                if (omnibus.userData.stopTimer > 2) {
                    // Done boarding, move to next stop
                    omnibus.userData.currentStop = omnibus.userData.nextStop;
                    omnibus.userData.nextStop = (omnibus.userData.nextStop + 1) % omnibusStops.length;
                    omnibus.userData.state = 'moving';
                }
            }
            
            // Randomly assign pedestrians to wait at stops
            if (Math.random() < 0.003) {
                assignPedToStop();
            }
        }
        
        function assignPedToStop() {
            // Find a random walking pedestrian near a bus stop
            const eligiblePeds = peds.filter(p => 
                p.userData.state === 'walking' && 
                !p.userData.waitingForBus
            );
            
            if (eligiblePeds.length === 0) return;
            
            const ped = eligiblePeds[Math.floor(Math.random() * eligiblePeds.length)];
            
            // Find nearest bus stop
            let nearestStop = null;
            let nearestDist = Infinity;
            omnibusStops.forEach(stop => {
                const dx = stop.x - ped.position.x;
                const dz = stop.z - ped.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < nearestDist && dist < 25) {
                    nearestDist = dist;
                    nearestStop = stop;
                }
            });
            
            if (nearestStop && nearestStop.waitingPeds.length < 4) {
                // Send pedestrian to bus stop
                ped.userData.waitingForBus = true;
                ped.userData.targetStop = nearestStop;
                ped.userData.state = 'toBusStop';
                
                // Position near the bench
                const offset = nearestStop.waitingPeds.length * 0.5;
                ped.userData.target = new THREE.Vector3(
                    nearestStop.x + 0.8 + offset * 0.3,
                    0.15,
                    nearestStop.z + (Math.random() - 0.5) * 0.5
                );
                
                nearestStop.waitingPeds.push(ped);
            }
        }
        
        function boardPassenger(stop) {
            if (stop.waitingPeds.length === 0) return;
            
            const ped = stop.waitingPeds.shift();
            if (ped) {
                // Remove from scene, add to bus
                ped.visible = false;
                ped.userData.state = 'onBus';
                ped.userData.waitingForBus = false;
                omnibusPassengers.push(ped);
            }
        }
        
        function disembarkPassenger(stop) {
            if (omnibusPassengers.length === 0) return;
            
            const ped = omnibusPassengers.shift();
            if (ped) {
                // Place near the bus stop
                ped.position.set(
                    stop.x + 1.5 + Math.random(),
                    0.15,
                    stop.z + (Math.random() - 0.5) * 2
                );
                ped.visible = true;
                ped.userData.state = 'walking';
                ped.userData.waitingForBus = false;
                
                // Find which block they're in
                const bx = Math.floor((ped.position.x + halfSize) / GRID.cellSize);
                const bz = Math.floor((ped.position.z + halfSize) / GRID.cellSize);
                ped.userData.currentBlock = { 
                    x: Math.max(0, Math.min(bx, GRID.gridCount - 1)), 
                    z: Math.max(0, Math.min(bz, GRID.gridCount - 1)) 
                };
                
                setNewPedTarget(ped);
            }
        }
        
        function updatePassengerDots() {
            if (!omnibus || !omnibus.userData.passengerDots) return;
            
            omnibus.userData.passengerDots.forEach((dot, i) => {
                if (i < omnibusPassengers.length) {
                    dot.material.color.setHex(0x44ff44);
                    dot.material.opacity = 1;
                } else {
                    dot.material.color.setHex(0x333333);
                    dot.material.opacity = 0.3;
                }
            });
        }

        function mkDoubleDecker() {
            const g = new THREE.Group();
            
            // Lower deck - red body
            const lowerBody = new THREE.Mesh(
                new THREE.BoxGeometry(4.5, 1.2, 1.8),
                new THREE.MeshStandardMaterial({ color: 0xcc0000, metalness: 0.3, roughness: 0.6 })
            );
            lowerBody.position.y = 0.8;
            lowerBody.castShadow = true;
            g.add(lowerBody);
            
            // Upper deck - open top
            const upperBody = new THREE.Mesh(
                new THREE.BoxGeometry(4.0, 0.9, 1.7),
                new THREE.MeshStandardMaterial({ color: 0xcc0000, metalness: 0.3, roughness: 0.6 })
            );
            upperBody.position.set(-0.2, 1.85, 0);
            upperBody.castShadow = true;
            g.add(upperBody);
            
            // Upper deck railing
            const railMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            // Front rail
            const frontRail = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.4, 1.6), railMat);
            frontRail.position.set(1.7, 2.5, 0);
            g.add(frontRail);
            // Side rails
            const sideRail1 = new THREE.Mesh(new THREE.BoxGeometry(3.8, 0.05, 0.05), railMat);
            sideRail1.position.set(-0.2, 2.5, 0.8);
            g.add(sideRail1);
            const sideRail2 = new THREE.Mesh(new THREE.BoxGeometry(3.8, 0.05, 0.05), railMat);
            sideRail2.position.set(-0.2, 2.5, -0.8);
            g.add(sideRail2);
            
            // Windows - lower deck
            const winMat = new THREE.MeshBasicMaterial({ color: 0x88ccff });
            for (let i = 0; i < 4; i++) {
                const win = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.6), winMat);
                win.position.set(-1.2 + i * 1.0, 0.9, 0.91);
                g.add(win);
                const win2 = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.6), winMat);
                win2.position.set(-1.2 + i * 1.0, 0.9, -0.91);
                win2.rotation.y = Math.PI;
                g.add(win2);
            }
            
            // Front windshield
            const windshield = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.8), winMat);
            windshield.position.set(2.26, 0.9, 0);
            windshield.rotation.y = Math.PI / 2;
            g.add(windshield);
            
            // "HOP ON HOP OFF" text panel on sides
            const textMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const textBg1 = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 0.4), textMat);
            textBg1.position.set(0, 1.2, 0.92);
            g.add(textBg1);
            const textBg2 = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 0.4), textMat);
            textBg2.position.set(0, 1.2, -0.92);
            textBg2.rotation.y = Math.PI;
            g.add(textBg2);
            
            // Text letters "HOP OFF" using small boxes
            const letterMat = new THREE.MeshBasicMaterial({ color: 0xcc0000 });
            const letters = "HOP OFF";
            for (let i = 0; i < letters.length; i++) {
                if (letters[i] !== ' ') {
                    const letter = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.02), letterMat);
                    letter.position.set(-0.9 + i * 0.3, 1.2, 0.93);
                    g.add(letter);
                    const letter2 = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.02), letterMat);
                    letter2.position.set(-0.9 + i * 0.3, 1.2, -0.93);
                    g.add(letter2);
                }
            }
            
            // Wheels (6 wheels - 2 front, 4 rear)
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const wheelPositions = [
                [1.5, 0.3, 0.9], [1.5, 0.3, -0.9],   // Front
                [-1.0, 0.3, 0.9], [-1.0, 0.3, -0.9], // Middle
                [-1.6, 0.3, 0.9], [-1.6, 0.3, -0.9]  // Rear
            ];
            wheelPositions.forEach(p => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.2, 12), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...p);
                g.add(wheel);
            });
            
            // Headlights
            const hlMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
            [0.6, -0.6].forEach(z => {
                const hl = new THREE.Mesh(new THREE.CircleGeometry(0.12), hlMat);
                hl.position.set(2.26, 0.5, z);
                hl.rotation.y = Math.PI / 2;
                g.add(hl);
            });
            
            // Passengers on upper deck (simple shapes)
            const passengerColors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0xaa96da, 0xfdcb6e];
            for (let i = 0; i < 6; i++) {
                const passenger = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15),
                    new THREE.MeshStandardMaterial({ color: passengerColors[i % passengerColors.length] })
                );
                passenger.position.set(-1.5 + i * 0.5, 2.6, (i % 2 === 0 ? 0.4 : -0.4));
                g.add(passenger);
            }
            
            return g;
        }

        function mkJitney() {
            const g = new THREE.Group();
            
            // Van body - varied colors for different routes
            const colors = [0x3366cc, 0x33aa55, 0xff9933, 0x9933cc];
            const bodyColor = colors[Math.floor(Math.random() * colors.length)];
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(3.0, 1.3, 1.4),
                new THREE.MeshStandardMaterial({ color: bodyColor, metalness: 0.4, roughness: 0.5 })
            );
            body.position.y = 0.85;
            body.castShadow = true;
            g.add(body);
            
            // Roof rack
            const roofRack = new THREE.Mesh(
                new THREE.BoxGeometry(2.0, 0.1, 1.2),
                new THREE.MeshStandardMaterial({ color: 0x444444 })
            );
            roofRack.position.set(-0.3, 1.6, 0);
            g.add(roofRack);
            
            // Route sign on top
            const signMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const sign = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.3, 0.1), signMat);
            sign.position.set(0.8, 1.75, 0);
            g.add(sign);
            
            // Windows
            const winMat = new THREE.MeshBasicMaterial({ color: 0x88ccff });
            // Side windows
            for (let i = 0; i < 3; i++) {
                const win = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.5), winMat);
                win.position.set(-0.5 + i * 0.8, 1.0, 0.71);
                g.add(win);
                const win2 = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.5), winMat);
                win2.position.set(-0.5 + i * 0.8, 1.0, -0.71);
                win2.rotation.y = Math.PI;
                g.add(win2);
            }
            
            // Front windshield
            const windshield = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.7), winMat);
            windshield.position.set(1.51, 1.0, 0);
            windshield.rotation.y = Math.PI / 2;
            g.add(windshield);
            
            // Sliding door indication (dark stripe)
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const door = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 1.0), doorMat);
            door.position.set(0.3, 0.8, 0.72);
            g.add(door);
            
            // Wheels (4 wheels)
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[1.0, 0.28, 0.7], [1.0, 0.28, -0.7], [-1.0, 0.28, 0.7], [-1.0, 0.28, -0.7]].forEach(p => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.28, 0.15, 12), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...p);
                g.add(wheel);
            });
            
            // Headlights
            const hlMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
            [0.45, -0.45].forEach(z => {
                const hl = new THREE.Mesh(new THREE.CircleGeometry(0.1), hlMat);
                hl.position.set(1.51, 0.5, z);
                hl.rotation.y = Math.PI / 2;
                g.add(hl);
            });
            
            // Tail lights
            const tlMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            [0.45, -0.45].forEach(z => {
                const tl = new THREE.Mesh(new THREE.CircleGeometry(0.08), tlMat);
                tl.position.set(-1.51, 0.5, z);
                tl.rotation.y = -Math.PI / 2;
                g.add(tl);
            });
            
            return g;
        }

        function addEmergencyLights(car, color1, color2) {
            const light1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.2, 0.3),
                new THREE.MeshBasicMaterial({ color: color1 })
            );
            light1.position.set(0.3, 1.1, 0);
            light1.userData.emergencyLight = true;
            light1.userData.lightColor = color1;
            car.add(light1);
            
            const light2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.2, 0.3),
                new THREE.MeshBasicMaterial({ color: color2 })
            );
            light2.position.set(-0.3, 1.1, 0);
            light2.userData.emergencyLight = true;
            light2.userData.lightColor = color2;
            car.add(light2);
        }

        function placeCarOnRoad(car) {
            const roadIdx = Math.floor(Math.random() * (GRID.gridCount + 1));
            const roadPos = -halfSize + roadIdx * GRID.cellSize;
            const isHorizontal = Math.random() > 0.5;
            const direction = Math.random() > 0.5 ? 1 : -1;
            const startPos = -halfSize + Math.random() * totalSize;
            
            // Right-side driving: lane offset depends on direction
            // X-axis: going +X stays on +Z side, going -X stays on -Z side
            // Z-axis: going +Z stays on -X side, going -Z stays on +X side
            let laneOffset;
            
            if (isHorizontal) {
                // X-axis road
                laneOffset = direction * 1.8; // +dir = +Z lane, -dir = -Z lane (correct)
                car.position.set(startPos, 0, roadPos + laneOffset);
                car.userData.roadPos = roadPos;
                car.userData.axis = 'x';
                car.userData.dir = direction;
                car.rotation.y = direction > 0 ? 0 : Math.PI;
            } else {
                // Z-axis road: flip the lane logic
                laneOffset = -direction * 1.8; // +dir(+Z) = -X lane, -dir(-Z) = +X lane
                car.position.set(roadPos + laneOffset, 0, startPos);
                car.userData.roadPos = roadPos;
                car.userData.axis = 'z';
                car.userData.dir = direction;
                car.rotation.y = direction > 0 ? -Math.PI / 2 : Math.PI / 2;
            }
            
            car.userData.laneOffset = laneOffset;
            car.userData.spd = 0.12 + Math.random() * 0.06;
            
            // Gridlock tracking
            car.userData.lastPos = { x: car.position.x, z: car.position.z };
            car.userData.stuckTime = 0;
            car.userData.beingHelped = false;
        }

        function mkCar(col) {
            const g = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 0.55, 1.1),
                new THREE.MeshStandardMaterial({ color: col, metalness: 0.6, roughness: 0.4 })
            );
            body.position.y = 0.38;
            body.castShadow = true;
            g.add(body);
            
            const cab = new THREE.Mesh(
                new THREE.BoxGeometry(1.1, 0.45, 1),
                new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.8, roughness: 0.2 })
            );
            cab.position.set(-0.2, 0.78, 0);
            g.add(cab);
            
            const wMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[0.6, 0.18, 0.5], [0.6, 0.18, -0.5], [-0.6, 0.18, 0.5], [-0.6, 0.18, -0.5]].forEach(p => {
                const w = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 0.12, 12), wMat);
                w.rotation.x = Math.PI / 2;
                w.position.set(...p);
                g.add(w);
            });
            
            const hlMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
            [0.35, -0.35].forEach(z => {
                const hl = new THREE.Mesh(new THREE.CircleGeometry(0.1), hlMat);
                hl.position.set(1.11, 0.38, z);
                hl.rotation.y = Math.PI / 2;
                g.add(hl);
            });
            
            const tlMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            [0.35, -0.35].forEach(z => {
                const tl = new THREE.Mesh(new THREE.CircleGeometry(0.1), tlMat);
                tl.position.set(-1.11, 0.38, z);
                tl.rotation.y = -Math.PI / 2;
                g.add(tl);
            });
            
            return g;
        }

        function mkPeds() {
            const cols = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0xaa96da, 0x6c5ce7, 0xfdcb6e];
            const innerSize = GRID.cellSize - GRID.roadWidth;
            
            for (let i = 0; i < CFG.peds; i++) {
                const p = mkPed(cols[Math.floor(Math.random() * cols.length)]);
                
                const bx = Math.floor(Math.random() * GRID.gridCount);
                const bz = Math.floor(Math.random() * GRID.gridCount);
                const blockCenterX = -halfSize + bx * GRID.cellSize + GRID.cellSize / 2;
                const blockCenterZ = -halfSize + bz * GRID.cellSize + GRID.cellSize / 2;
                
                const side = Math.floor(Math.random() * 4);
                const swOffset = GRID.sidewalkWidth / 2;
                const alongOffset = (Math.random() - 0.5) * (innerSize - 4);
                
                if (side === 0) p.position.set(blockCenterX + alongOffset, 0.15, blockCenterZ - innerSize/2 + swOffset);
                else if (side === 1) p.position.set(blockCenterX + alongOffset, 0.15, blockCenterZ + innerSize/2 - swOffset);
                else if (side === 2) p.position.set(blockCenterX - innerSize/2 + swOffset, 0.15, blockCenterZ + alongOffset);
                else p.position.set(blockCenterX + innerSize/2 - swOffset, 0.15, blockCenterZ + alongOffset);
                
                p.userData.currentBlock = { x: bx, z: bz };
                p.userData.state = 'walking';
                setNewPedTarget(p);
                
                p.userData.spd = 0.02 + Math.random() * 0.015;
                p.userData.walk = Math.random() * Math.PI * 2;
                peds.push(p);
                scene.add(p);
            }
        }

        function setNewPedTarget(p) {
            const innerSize = GRID.cellSize - GRID.roadWidth;
            const bx = p.userData.currentBlock.x;
            const bz = p.userData.currentBlock.z;
            const blockCenterX = -halfSize + bx * GRID.cellSize + GRID.cellSize / 2;
            const blockCenterZ = -halfSize + bz * GRID.cellSize + GRID.cellSize / 2;
            const swOffset = GRID.sidewalkWidth / 2;
            
            // Determine which side of sidewalk pedestrian is currently on
            const relX = p.position.x - blockCenterX;
            const relZ = p.position.z - blockCenterZ;
            const halfInner = innerSize / 2;
            
            // Figure out current sidewalk side (0=north, 1=south, 2=west, 3=east)
            let currentSide = -1;
            if (Math.abs(relZ + halfInner) < 2) currentSide = 0; // North sidewalk
            else if (Math.abs(relZ - halfInner) < 2) currentSide = 1; // South sidewalk
            else if (Math.abs(relX + halfInner) < 2) currentSide = 2; // West sidewalk
            else if (Math.abs(relX - halfInner) < 2) currentSide = 3; // East sidewalk
            
            // 20% chance to cross to another block
            if (Math.random() < 0.20 && p.userData.state === 'walking') {
                const dir = Math.floor(Math.random() * 4);
                let newBx = bx, newBz = bz;
                
                if (dir === 0 && bz > 0) newBz--;
                else if (dir === 1 && bz < GRID.gridCount - 1) newBz++;
                else if (dir === 2 && bx > 0) newBx--;
                else if (dir === 3 && bx < GRID.gridCount - 1) newBx++;
                
                if (newBx !== bx || newBz !== bz) {
                    const crosswalk = findNearestCrosswalk(p.position, newBx - bx, newBz - bz);
                    if (crosswalk) {
                        p.userData.state = 'towardsCrosswalk';
                        p.userData.pendingCrosswalk = crosswalk;
                        p.userData.pendingBlock = { x: newBx, z: newBz };
                        
                        if (crosswalk.axis === 'z') {
                            p.userData.target = new THREE.Vector3(crosswalk.x, 0.15, crosswalk.z - GRID.roadWidth/2 + 1);
                        } else {
                            p.userData.target = new THREE.Vector3(crosswalk.x - GRID.roadWidth/2 + 1, 0.15, crosswalk.z);
                        }
                        return;
                    }
                }
            }
            
            // 10% chance to go to a building entrance on CURRENT sidewalk side
            if (Math.random() < 0.10 && buildingEntrances.length > 0 && currentSide >= 0) {
                // Find entrance on the same side we're walking on
                let validEntrances = buildingEntrances.filter(ent => {
                    // Check if entrance is in this block
                    const dx = Math.abs(ent.x - blockCenterX);
                    const dz = Math.abs(ent.z - blockCenterZ);
                    if (dx > halfInner + 2 || dz > halfInner + 2) return false;
                    
                    // Check if entrance faces the sidewalk we're on
                    if (currentSide === 0 && ent.side === 1) return true; // North sidewalk, door faces north
                    if (currentSide === 1 && ent.side === 0) return true; // South sidewalk, door faces south
                    if (currentSide === 2 && ent.side === 3) return true; // West sidewalk, door faces west
                    if (currentSide === 3 && ent.side === 2) return true; // East sidewalk, door faces east
                    return false;
                });
                
                if (validEntrances.length > 0) {
                    const entrance = validEntrances[Math.floor(Math.random() * validEntrances.length)];
                    p.userData.state = 'toBuilding';
                    p.userData.targetEntrance = entrance;
                    p.userData.target = new THREE.Vector3(entrance.x, 0.15, entrance.z);
                    return;
                }
            }
            
            // Default: walk along current sidewalk to a random point, staying on same side
            let targetX, targetZ;
            const alongOffset = (Math.random() - 0.5) * (innerSize - 2);
            
            if (currentSide === 0 || currentSide === 1) {
                // On north or south sidewalk - walk east/west
                targetX = blockCenterX + alongOffset;
                targetZ = currentSide === 0 ? blockCenterZ - halfInner + swOffset : blockCenterZ + halfInner - swOffset;
            } else if (currentSide === 2 || currentSide === 3) {
                // On west or east sidewalk - walk north/south
                targetX = currentSide === 2 ? blockCenterX - halfInner + swOffset : blockCenterX + halfInner - swOffset;
                targetZ = blockCenterZ + alongOffset;
            } else {
                // Not on a sidewalk - pick nearest sidewalk corner
                const side = Math.floor(Math.random() * 4);
                if (side === 0) {
                    targetX = blockCenterX + alongOffset;
                    targetZ = blockCenterZ - halfInner + swOffset;
                } else if (side === 1) {
                    targetX = blockCenterX + alongOffset;
                    targetZ = blockCenterZ + halfInner - swOffset;
                } else if (side === 2) {
                    targetX = blockCenterX - halfInner + swOffset;
                    targetZ = blockCenterZ + alongOffset;
                } else {
                    targetX = blockCenterX + halfInner - swOffset;
                    targetZ = blockCenterZ + alongOffset;
                }
            }
            
            p.userData.target = new THREE.Vector3(targetX, 0.15, targetZ);
            p.userData.state = 'walking';
        }

        function findNearestCrosswalk(pos, dx, dz) {
            let best = null, bestDist = Infinity;
            
            for (const cw of crosswalks) {
                if ((dz !== 0 && cw.axis === 'z') || (dx !== 0 && cw.axis === 'x')) {
                    const dist = Math.abs(pos.x - cw.x) + Math.abs(pos.z - cw.z);
                    if (dist < bestDist) {
                        bestDist = dist;
                        best = cw;
                    }
                }
            }
            return best;
        }

        function mkPed(col) {
            const g = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.18, 0.6, 8),
                new THREE.MeshStandardMaterial({ color: col })
            );
            body.position.y = 0.5;
            body.castShadow = true;
            g.add(body);
            
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0xffcc99 })
            );
            head.position.y = 0.95;
            g.add(head);
            
            const legMat = new THREE.MeshStandardMaterial({ color: 0x333355 });
            const ll = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.4, 6), legMat);
            ll.position.set(0.07, 0.2, 0);
            g.add(ll);
            
            const rl = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.4, 6), legMat);
            rl.position.set(-0.07, 0.2, 0);
            g.add(rl);
            
            g.userData.ll = ll;
            g.userData.rl = rl;
            return g;
        }

        function mkBicycles() {
            for (let i = 0; i < CFG.bikes; i++) {
                spawnBicycle();
            }
        }

        function spawnBicycle() {
            const bike = mkBicycle();
            
            // Always spawn on road
            const roadIdx = Math.floor(Math.random() * (GRID.gridCount + 1));
            const roadPos = -halfSize + roadIdx * GRID.cellSize;
            const direction = Math.random() > 0.5 ? 1 : -1;
            const startPos = direction > 0 ? -halfSize - 5 : halfSize + 5;
            
            // Right-side driving lane assignment
            if (Math.random() > 0.5) {
                // X-axis road: +dir = +Z lane, -dir = -Z lane
                const laneOffset = direction * 1.8;
                bike.position.set(startPos, 0.35, roadPos + laneOffset);
                bike.userData.axis = 'x';
                bike.userData.roadPos = roadPos;
                bike.userData.laneOffset = laneOffset;
            } else {
                // Z-axis road: +dir(+Z) = -X lane, -dir(-Z) = +X lane
                const laneOffset = -direction * 1.8;
                bike.position.set(roadPos + laneOffset, 0.35, startPos);
                bike.userData.axis = 'z';
                bike.userData.roadPos = roadPos;
                bike.userData.laneOffset = laneOffset;
            }
            
            bike.userData.dir = direction;
            bike.userData.spd = 0.06 + Math.random() * 0.03;
            bike.userData.stopped = false;
            bike.userData.stoppedTime = 0;
            // Bike front is +X, so to face +Z we rotate -90¬∞, to face -Z we rotate +90¬∞
            bike.rotation.y = bike.userData.axis === 'x' ? 
                (direction > 0 ? 0 : Math.PI) : 
                (direction > 0 ? -Math.PI / 2 : Math.PI / 2);
            
            bicycles.push(bike);
            scene.add(bike);
            return bike;
        }

        function mkBicycle() {
            const g = new THREE.Group();
            
            // Wheels - oriented to roll in X direction (forward)
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const wheelGeo = new THREE.TorusGeometry(0.35, 0.05, 8, 16);
            
            const frontWheel = new THREE.Mesh(wheelGeo, wheelMat);
            frontWheel.rotation.z = Math.PI / 2; // Wheel rolls forward
            frontWheel.position.set(0.6, 0, 0);
            g.add(frontWheel);
            
            const backWheel = new THREE.Mesh(wheelGeo, wheelMat);
            backWheel.rotation.z = Math.PI / 2; // Wheel rolls forward
            backWheel.position.set(-0.6, 0, 0);
            g.add(backWheel);
            
            // Frame
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xff4444 });
            const frame = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.08, 0.08), frameMat);
            frame.position.set(0, 0.25, 0);
            g.add(frame);
            
            const seatPost = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4), frameMat);
            seatPost.position.set(-0.3, 0.45, 0);
            g.add(seatPost);
            
            const handlebar = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.4), frameMat);
            handlebar.position.set(0.5, 0.5, 0);
            g.add(handlebar);
            
            // Rider
            const riderMat = new THREE.MeshStandardMaterial({ color: 0x44aaff });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.15, 0.5, 8), riderMat);
            body.position.set(-0.1, 0.9, 0);
            g.add(body);
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshStandardMaterial({ color: 0xffcc99 }));
            head.position.set(0.1, 1.2, 0);
            g.add(head);
            
            // Helmet
            const helmet = new THREE.Mesh(
                new THREE.SphereGeometry(0.14, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                new THREE.MeshStandardMaterial({ color: 0xffff00 })
            );
            helmet.position.set(0.1, 1.28, 0);
            g.add(helmet);
            
            g.userData.frontWheel = frontWheel;
            g.userData.backWheel = backWheel;
            
            return g;
        }

        function updBicycles(t) {
            const policecar = emergencyVehicles.find(ev => ev.userData.emergencyType === 'police');
            
            bicycles.forEach((bike, idx) => {
                // Check if police is chasing this bike
                if (policeChaseTarget === bike) {
                    if (bike.userData.stopped) {
                        // Bike is stopped, police caught it - remove immediately
                        bike.userData.stoppedTime += 0.016;
                        if (bike.userData.stoppedTime > 2) {
                            // Remove bike immediately after arrest
                            scene.remove(bike);
                            bicycles.splice(idx, 1);
                            policeChaseTarget = null;
                            
                            // Return police to nearest road
                            if (policecar) {
                                policecar.userData.returningToRoad = true;
                            }
                            
                            // Respawn a new bike later
                            setTimeout(() => spawnBicycle(), 8000);
                        }
                        return;
                    }
                }
                
                // Check if police spots this bike (only on roads, not chasing already)
                if (!bike.userData.stopped && policecar && !policeChaseTarget && !policecar.userData.returningToRoad) {
                    const dx = policecar.position.x - bike.position.x;
                    const dz = policecar.position.z - bike.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    // Only chase if both are on roads
                    if (dist < 20) {
                        policeChaseTarget = bike;
                    }
                }
                
                // If being chased, try to escape but eventually stop
                if (policeChaseTarget === bike && policecar) {
                    const dx = policecar.position.x - bike.position.x;
                    const dz = policecar.position.z - bike.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 2.5) {
                        // Caught!
                        bike.userData.stopped = true;
                        bike.userData.stoppedTime = 0;
                        return;
                    }
                    
                    // Speed up slightly to try to escape
                    bike.userData.spd = 0.10;
                }
                
                // Move bike (ignores traffic lights!)
                if (!bike.userData.stopped) {
                    // Check for collisions ahead
                    let blocked = false;
                    const lookAhead = bike.userData.spd * 8;
                    const nextX = bike.position.x + (bike.userData.axis === 'x' ? lookAhead * bike.userData.dir : 0);
                    const nextZ = bike.position.z + (bike.userData.axis === 'z' ? lookAhead * bike.userData.dir : 0);
                    
                    // Check buildings
                    for (const b of buildings) {
                        const bw = b.userData.width || 6;
                        const bd = b.userData.depth || 6;
                        const dx = Math.abs(nextX - b.position.x);
                        const dz = Math.abs(nextZ - b.position.z);
                        if (dx < bw/2 + 1 && dz < bd/2 + 1) {
                            blocked = true;
                            break;
                        }
                    }
                    
                    // Check cars ahead - stop if car is in front
                    if (!blocked) {
                        for (const car of cars) {
                            const dx = car.position.x - bike.position.x;
                            const dz = car.position.z - bike.position.z;
                            
                            // Check if car is ahead of bike
                            if (bike.userData.axis === 'x') {
                                const ahead = dx * bike.userData.dir;
                                const lateral = Math.abs(dz);
                                if (ahead > 0 && ahead < 5 && lateral < 2) {
                                    blocked = true;
                                    break;
                                }
                            } else {
                                const ahead = dz * bike.userData.dir;
                                const lateral = Math.abs(dx);
                                if (ahead > 0 && ahead < 5 && lateral < 2) {
                                    blocked = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Check omnibus
                    if (!blocked && omnibus) {
                        const dx = omnibus.position.x - bike.position.x;
                        const dz = omnibus.position.z - bike.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < 4) {
                            blocked = true;
                        }
                    }
                    
                    // Check garbage truck
                    if (!blocked && garbageTruck && garbageTruckActive) {
                        const dx = garbageTruck.position.x - bike.position.x;
                        const dz = garbageTruck.position.z - bike.position.z;
                        
                        if (bike.userData.axis === 'x') {
                            const ahead = dx * bike.userData.dir;
                            const lateral = Math.abs(dz);
                            if (ahead > 0 && ahead < 8 && lateral < 3) {
                                blocked = true;
                            }
                        } else {
                            const ahead = dz * bike.userData.dir;
                            const lateral = Math.abs(dx);
                            if (ahead > 0 && ahead < 8 && lateral < 3) {
                                blocked = true;
                            }
                        }
                    }
                    
                    // Check special event vehicles (semi truck, parade, etc)
                    if (!blocked && specialEvent && specialEvent.entities) {
                        for (const entity of specialEvent.entities) {
                            const dx = entity.position.x - bike.position.x;
                            const dz = entity.position.z - bike.position.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            if (dist < 5) {
                                blocked = true;
                                break;
                            }
                        }
                    }
                    
                    // Bikes weave around pedestrians - no blocking check needed
                    
                    if (blocked) {
                        // Stop or turn around quickly
                        bike.userData.waitTime = (bike.userData.waitTime || 0) + 0.016;
                        if (bike.userData.waitTime > 0.5) {
                            // Waited too long, turn around
                            bike.userData.dir *= -1;
                            bike.rotation.y = bike.userData.axis === 'x' ? 
                                (bike.userData.dir > 0 ? 0 : Math.PI) : 
                                (bike.userData.dir > 0 ? -Math.PI / 2 : Math.PI / 2);
                            bike.userData.waitTime = 0;
                        }
                    } else {
                        bike.userData.waitTime = 0;
                        
                        // Move at normal speed
                        const moveSpeed = bike.userData.spd;
                        
                        // Spin wheels
                        if (bike.userData.frontWheel) {
                            bike.userData.frontWheel.rotation.x += 0.2;
                            bike.userData.backWheel.rotation.x += 0.2;
                        }
                        
                        if (bike.userData.axis === 'x') {
                            bike.position.x += moveSpeed * bike.userData.dir;
                            if (bike.position.x > halfSize + 10 || bike.position.x < -halfSize - 10) {
                                bike.userData.dir *= -1;
                                bike.rotation.y = bike.userData.dir > 0 ? 0 : Math.PI;
                            }
                        } else {
                            bike.position.z += bike.userData.spd * bike.userData.dir;
                            if (bike.position.z > halfSize + 10 || bike.position.z < -halfSize - 10) {
                                bike.userData.dir *= -1;
                                bike.rotation.y = bike.userData.dir > 0 ? -Math.PI / 2 : Math.PI / 2;
                            }
                        }
                        
                        // Randomly change direction sometimes (but check if clear)
                        if (Math.random() < 0.002) {
                            const newAxis = bike.userData.axis === 'x' ? 'z' : 'x';
                            // Only switch if on a road
                            let canSwitch = false;
                            for (let i = 0; i <= GRID.gridCount; i++) {
                                const roadPos = -halfSize + i * GRID.cellSize;
                                if (newAxis === 'z' && Math.abs(bike.position.x - roadPos) < GRID.roadWidth / 2) canSwitch = true;
                                if (newAxis === 'x' && Math.abs(bike.position.z - roadPos) < GRID.roadWidth / 2) canSwitch = true;
                            }
                            if (canSwitch) {
                                bike.userData.axis = newAxis;
                                bike.rotation.y = bike.userData.axis === 'x' ? 
                                    (bike.userData.dir > 0 ? 0 : Math.PI) : 
                                    (bike.userData.dir > 0 ? -Math.PI / 2 : Math.PI / 2);
                            }
                        }
                    }
                }
            });
            
            // Police chase behavior
            if (policeChaseTarget && policecar && !policeChaseTarget.userData.stopped) {
                const bike = policeChaseTarget;
                const dx = bike.position.x - policecar.position.x;
                const dz = bike.position.z - policecar.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist > 1) {
                    // Move police toward bike
                    const speed = 0.22;
                    policecar.position.x += (dx / dist) * speed;
                    policecar.position.z += (dz / dist) * speed;
                    policecar.rotation.y = Math.atan2(dx, dz);
                }
            }
            
            // Police returning to road after chase
            if (policecar && policecar.userData.returningToRoad) {
                // Find nearest road
                let nearestRoadX = -halfSize;
                let nearestRoadZ = -halfSize;
                let minDistX = Infinity;
                let minDistZ = Infinity;
                
                for (let i = 0; i <= GRID.gridCount; i++) {
                    const roadPos = -halfSize + i * GRID.cellSize;
                    const distX = Math.abs(policecar.position.x - roadPos);
                    const distZ = Math.abs(policecar.position.z - roadPos);
                    if (distX < minDistX) { minDistX = distX; nearestRoadX = roadPos; }
                    if (distZ < minDistZ) { minDistZ = distZ; nearestRoadZ = roadPos; }
                }
                
                // Move toward nearest road
                if (minDistX < minDistZ) {
                    // Move to X road
                    const diff = nearestRoadX - policecar.position.x;
                    if (Math.abs(diff) > 0.5) {
                        policecar.position.x += Math.sign(diff) * 0.1;
                    } else {
                        policecar.userData.returningToRoad = false;
                        policecar.userData.axis = 'z';
                        policecar.userData.dir = Math.random() > 0.5 ? 1 : -1;
                        placeCarOnRoad(policecar);
                    }
                } else {
                    // Move to Z road
                    const diff = nearestRoadZ - policecar.position.z;
                    if (Math.abs(diff) > 0.5) {
                        policecar.position.z += Math.sign(diff) * 0.1;
                    } else {
                        policecar.userData.returningToRoad = false;
                        policecar.userData.axis = 'x';
                        policecar.userData.dir = Math.random() > 0.5 ? 1 : -1;
                        placeCarOnRoad(policecar);
                    }
                }
            }
        }

        // ============ GARBAGE TRUCK SYSTEM ============
        
        function mkGarbageTruck() {
            const g = new THREE.Group();
            
            // Main truck body - very large
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2d5016, metalness: 0.3, roughness: 0.7 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(6, 3, 2.5), bodyMat);
            body.position.set(0, 1.8, 0);
            body.castShadow = true;
            g.add(body);
            
            // Cab
            const cab = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2.3), bodyMat);
            cab.position.set(3.5, 1.3, 0);
            cab.castShadow = true;
            g.add(cab);
            
            // Windshield
            const winMat = new THREE.MeshBasicMaterial({ color: 0x88ccff });
            const windshield = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.2), winMat);
            windshield.position.set(4.51, 1.6, 0);
            windshield.rotation.y = Math.PI / 2;
            g.add(windshield);
            
            // Giant suction nozzle on front
            const nozzleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.5, 3, 16), nozzleMat);
            nozzle.rotation.z = Math.PI / 2;
            nozzle.position.set(5.5, 1.5, 0);
            g.add(nozzle);
            g.userData.nozzle = nozzle;
            
            // Suction opening with spinning effect
            const suctionRing = new THREE.Mesh(
                new THREE.TorusGeometry(1.2, 0.15, 8, 24),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            suctionRing.rotation.y = Math.PI / 2;
            suctionRing.position.set(7, 1.5, 0);
            g.add(suctionRing);
            g.userData.suctionRing = suctionRing;
            
            // "TILT" lights on sides (initially off)
            const tiltLights = [];
            const letters = ['T', 'I', 'L', 'T'];
            letters.forEach((letter, i) => {
                // Left side
                const lightL = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.8, 0.1),
                    new THREE.MeshBasicMaterial({ color: 0x331111 })
                );
                lightL.position.set(-1.5 + i * 1.2, 2.8, 1.26);
                lightL.userData.tiltLight = true;
                tiltLights.push(lightL);
                g.add(lightL);
                
                // Right side
                const lightR = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.8, 0.1),
                    new THREE.MeshBasicMaterial({ color: 0x331111 })
                );
                lightR.position.set(-1.5 + i * 1.2, 2.8, -1.26);
                lightR.userData.tiltLight = true;
                tiltLights.push(lightR);
                g.add(lightR);
            });
            g.userData.tiltLights = tiltLights;
            
            // Warning lights on top
            const warningLight1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.3),
                new THREE.MeshBasicMaterial({ color: 0xff6600 })
            );
            warningLight1.position.set(0, 3.5, 0.8);
            warningLight1.userData.warningLight = true;
            g.add(warningLight1);
            
            const warningLight2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.3),
                new THREE.MeshBasicMaterial({ color: 0xff6600 })
            );
            warningLight2.position.set(0, 3.5, -0.8);
            warningLight2.userData.warningLight = true;
            g.add(warningLight2);
            
            // Wheels (8 wheels)
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const wheelPositions = [
                [3, 0.5, 1.3], [3, 0.5, -1.3],
                [0.5, 0.5, 1.3], [0.5, 0.5, -1.3],
                [-1.5, 0.5, 1.3], [-1.5, 0.5, -1.3],
                [-2.5, 0.5, 1.3], [-2.5, 0.5, -1.3]
            ];
            wheelPositions.forEach(p => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.3, 12), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...p);
                g.add(wheel);
            });
            
            // Headlights
            const hlMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
            [0.8, -0.8].forEach(z => {
                const hl = new THREE.Mesh(new THREE.CircleGeometry(0.2), hlMat);
                hl.position.set(4.51, 0.8, z);
                hl.rotation.y = Math.PI / 2;
                g.add(hl);
            });
            
            return g;
        }
        
        function spawnGarbageTruck() {
            if (garbageTruck) {
                scene.remove(garbageTruck);
            }
            
            garbageTruck = mkGarbageTruck();
            
            // Start from edge of city
            const roadIdx = Math.floor(Math.random() * (GRID.gridCount + 1));
            const roadPos = -halfSize + roadIdx * GRID.cellSize;
            const dir = Math.random() > 0.5 ? 1 : -1;
            const startX = dir > 0 ? -halfSize - 20 : halfSize + 20;
            
            // Right-side driving: +dir = +Z lane
            const laneOffset = dir * 1.8;
            
            garbageTruck.position.set(startX, 0, roadPos + laneOffset);
            garbageTruck.userData.axis = 'x';
            garbageTruck.userData.dir = dir;
            garbageTruck.userData.spd = 0.06;
            garbageTruck.userData.roadPos = roadPos;
            garbageTruck.userData.laneOffset = laneOffset;
            garbageTruck.userData.turnTimer = 0;
            garbageTruck.userData.suckedPeds = 0;
            garbageTruck.rotation.y = dir > 0 ? 0 : Math.PI;
            
            scene.add(garbageTruck);
            garbageTruckActive = true;
            suctionActive = true;
            
            notify('üöõüí® GARBAGE TRUCK! Watch out for the suction!', 4000);
        }
        
        function updGarbageTruck(t) {
            // Spawn every 3 minutes (180 seconds)
            if (!garbageTruckActive && t - lastGarbageTruck > 180) {
                spawnGarbageTruck();
                lastGarbageTruck = t;
            }
            
            if (!garbageTruck || !garbageTruckActive) return;
            
            const truck = garbageTruck;
            
            // Animate warning lights
            truck.traverse(child => {
                if (child.userData.warningLight) {
                    child.material.color.setHex(Math.sin(t * 10) > 0 ? 0xff6600 : 0x663300);
                }
            });
            
            // Animate suction ring spinning
            if (truck.userData.suctionRing) {
                truck.userData.suctionRing.rotation.x += 0.2;
            }
            
            // Check for pedestrians to suck up
            let suckedSomeone = false;
            const nozzleWorldPos = new THREE.Vector3();
            if (truck.userData.axis === 'x') {
                nozzleWorldPos.set(
                    truck.position.x + truck.userData.dir * 7,
                    1.5,
                    truck.position.z
                );
            } else {
                nozzleWorldPos.set(
                    truck.position.x,
                    1.5,
                    truck.position.z + truck.userData.dir * 7
                );
            }
            
            for (let i = peds.length - 1; i >= 0; i--) {
                const ped = peds[i];
                if (!ped.visible) continue;
                
                const dx = ped.position.x - nozzleWorldPos.x;
                const dz = ped.position.z - nozzleWorldPos.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < 5) {
                    // Suck up the pedestrian!
                    suckedSomeone = true;
                    scene.remove(ped);
                    peds.splice(i, 1);
                    truck.userData.suckedPeds++;
                    
                    // Spawn a new pedestrian from a building door after delay
                    setTimeout(() => {
                        if (buildingEntrances.length === 0) return;
                        
                        const cols = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181];
                        const p = mkPed(cols[Math.floor(Math.random() * cols.length)]);
                        
                        // Pick a random building entrance
                        const entrance = buildingEntrances[Math.floor(Math.random() * buildingEntrances.length)];
                        
                        // Position at door, slightly in front
                        let spawnX = entrance.x;
                        let spawnZ = entrance.z;
                        if (entrance.side === 0) spawnZ += 1;
                        else if (entrance.side === 1) spawnZ -= 1;
                        else if (entrance.side === 2) spawnX += 1;
                        else spawnX -= 1;
                        
                        p.position.set(spawnX, 0.15, spawnZ);
                        
                        // Find which block this is in
                        const bx = Math.floor((spawnX + halfSize) / GRID.cellSize);
                        const bz = Math.floor((spawnZ + halfSize) / GRID.cellSize);
                        
                        p.userData.currentBlock = { x: Math.max(0, Math.min(bx, GRID.gridCount - 1)), z: Math.max(0, Math.min(bz, GRID.gridCount - 1)) };
                        p.userData.state = 'exitingBuilding';
                        p.userData.spd = 0.02 + Math.random() * 0.015;
                        p.userData.walk = Math.random() * Math.PI * 2;
                        
                        // Set target to sidewalk
                        const blockCenterX = -halfSize + p.userData.currentBlock.x * GRID.cellSize + GRID.cellSize / 2;
                        const blockCenterZ = -halfSize + p.userData.currentBlock.z * GRID.cellSize + GRID.cellSize / 2;
                        const innerSize = GRID.cellSize - GRID.roadWidth;
                        const swOffset = GRID.sidewalkWidth / 2;
                        const side = Math.floor(Math.random() * 4);
                        if (side === 0) p.userData.target = new THREE.Vector3(blockCenterX, 0.15, blockCenterZ - innerSize/2 + swOffset);
                        else if (side === 1) p.userData.target = new THREE.Vector3(blockCenterX, 0.15, blockCenterZ + innerSize/2 - swOffset);
                        else if (side === 2) p.userData.target = new THREE.Vector3(blockCenterX - innerSize/2 + swOffset, 0.15, blockCenterZ);
                        else p.userData.target = new THREE.Vector3(blockCenterX + innerSize/2 - swOffset, 0.15, blockCenterZ);
                        
                        peds.push(p);
                        scene.add(p);
                    }, 5000);
                }
            }
            
            // TILT lights when sucking someone
            if (suckedSomeone || truck.userData.suckedPeds > 0) {
                truck.userData.tiltLights.forEach((light, i) => {
                    const flash = Math.sin(t * 15 + i) > 0;
                    light.material.color.setHex(flash ? 0xff0000 : 0x330000);
                });
            }
            
            // Move the truck
            truck.userData.turnTimer += 0.016;
            
            // Randomly turn at intersections
            if (truck.userData.turnTimer > 3) {
                truck.userData.turnTimer = 0;
                if (Math.random() < 0.3) {
                    // Try to turn
                    const newAxis = truck.userData.axis === 'x' ? 'z' : 'x';
                    // Find nearest road
                    let nearestRoad = truck.userData.roadPos;
                    let minDist = Infinity;
                    for (let i = 0; i <= GRID.gridCount; i++) {
                        const rp = -halfSize + i * GRID.cellSize;
                        const dist = truck.userData.axis === 'x' ? 
                            Math.abs(truck.position.x - rp) : 
                            Math.abs(truck.position.z - rp);
                        if (dist < minDist && dist < 3) {
                            minDist = dist;
                            nearestRoad = rp;
                        }
                    }
                    
                    if (minDist < 3) {
                        truck.userData.axis = newAxis;
                        truck.userData.roadPos = nearestRoad;
                        truck.userData.dir = Math.random() > 0.5 ? 1 : -1;
                        
                        // Right-side driving lane assignment
                        if (newAxis === 'x') {
                            truck.userData.laneOffset = truck.userData.dir * 1.8;
                        } else {
                            truck.userData.laneOffset = -truck.userData.dir * 1.8;
                        }
                        
                        truck.rotation.y = truck.userData.axis === 'x' ? 
                            (truck.userData.dir > 0 ? 0 : Math.PI) : 
                            (truck.userData.dir > 0 ? -Math.PI / 2 : Math.PI / 2);
                    }
                }
            }
            
            // Move truck - check for obstacles first
            let truckBlocked = false;
            
            // Check for cars ahead - but only cars that are actually blocking
            for (const car of cars) {
                const dx = car.position.x - truck.position.x;
                const dz = car.position.z - truck.position.z;
                
                if (truck.userData.axis === 'x') {
                    const ahead = dx * truck.userData.dir;
                    const lateral = Math.abs(dz - truck.userData.roadPos);
                    if (ahead > 0 && ahead < 6 && lateral < 2.5) {
                        truckBlocked = true;
                        break;
                    }
                } else {
                    const ahead = dz * truck.userData.dir;
                    const lateral = Math.abs(dx - truck.userData.roadPos);
                    if (ahead > 0 && ahead < 6 && lateral < 2.5) {
                        truckBlocked = true;
                        break;
                    }
                }
            }
            
            // Track stuck time
            truck.userData.stuckTime = truck.userData.stuckTime || 0;
            
            if (truckBlocked) {
                truck.userData.stuckTime += 0.016;
                
                // If stuck for more than 3 seconds, force move or turn
                if (truck.userData.stuckTime > 3) {
                    // Try turning around or switching roads
                    if (Math.random() < 0.5) {
                        truck.userData.dir *= -1;
                        // Update lane for new direction
                        if (truck.userData.axis === 'x') {
                            truck.userData.laneOffset = truck.userData.dir * 1.8;
                        } else {
                            truck.userData.laneOffset = -truck.userData.dir * 1.8;
                        }
                        truck.rotation.y = truck.userData.axis === 'x' ? 
                            (truck.userData.dir > 0 ? 0 : Math.PI) : 
                            (truck.userData.dir > 0 ? -Math.PI / 2 : Math.PI / 2);
                    } else {
                        // Switch to perpendicular road
                        truck.userData.axis = truck.userData.axis === 'x' ? 'z' : 'x';
                        // Update lane for new axis
                        if (truck.userData.axis === 'x') {
                            truck.userData.laneOffset = truck.userData.dir * 1.8;
                        } else {
                            truck.userData.laneOffset = -truck.userData.dir * 1.8;
                        }
                        truck.rotation.y = truck.userData.axis === 'x' ? 
                            (truck.userData.dir > 0 ? 0 : Math.PI) : 
                            (truck.userData.dir > 0 ? -Math.PI / 2 : Math.PI / 2);
                    }
                    truck.userData.stuckTime = 0;
                    truckBlocked = false; // Force move
                }
            } else {
                truck.userData.stuckTime = 0;
            }
            
            if (!truckBlocked) {
                if (truck.userData.axis === 'x') {
                    truck.position.x += truck.userData.spd * truck.userData.dir;
                    truck.position.z = truck.userData.roadPos + (truck.userData.laneOffset || 0);
                } else {
                    truck.position.z += truck.userData.spd * truck.userData.dir;
                    truck.position.x = truck.userData.roadPos + (truck.userData.laneOffset || 0);
                }
            }
            
            // Remove truck when it leaves the city
            if (truck.position.x > halfSize + 30 || truck.position.x < -halfSize - 30 ||
                truck.position.z > halfSize + 30 || truck.position.z < -halfSize - 30) {
                scene.remove(garbageTruck);
                garbageTruck = null;
                garbageTruckActive = false;
                suctionActive = false;
                if (truck.userData.suckedPeds > 0) {
                    notify(`üöõ Garbage truck left. Collected ${truck.userData.suckedPeds} pedestrians!`, 3000);
                }
            }
        }

        // ============ FALLING PERSON SYSTEM ============
        
        function updFallingPerson(t) {
            // Trigger event every 3 minutes (180 seconds)
            if (fallState === 'none' && t - lastFallEvent > 180) {
                startFallEvent(t);
                lastFallEvent = t;
            }
            
            if (fallState === 'none') return;
            
            fallEventTimer += 0.016;
            
            switch (fallState) {
                case 'inWindow':
                    // Flash the window 5 times (0.3s on, 0.3s off = 0.6s per flash, 3s total)
                    if (flashingWindow) {
                        const flashPhase = Math.floor(fallEventTimer / 0.3);
                        const isOn = flashPhase % 2 === 0;
                        flashingWindow.material.color.setHex(isOn ? 0xff0000 : 0xffeeaa);
                        flashingWindow.material.needsUpdate = true;
                        
                        if (flashPhase >= 10) {
                            // Done flashing, restore window
                            flashingWindow.material.color.setHex(0x334455);
                            flashingWindow = null;
                        }
                    }
                    
                    // Person visible in window for 3 seconds
                    if (fallingPerson) {
                        // Make person wave/move slightly
                        fallingPerson.position.y += Math.sin(t * 10) * 0.005;
                    }
                    if (fallEventTimer > 3) {
                        // Start falling
                        fallState = 'falling';
                        fallEventTimer = 0;
                        if (fallingPerson) {
                            fallingPerson.userData.velY = 0;
                        }
                    }
                    break;
                    
                case 'falling':
                    // Clean up flashing window
                    if (flashingWindow) {
                        scene.remove(flashingWindow);
                        flashingWindow = null;
                    }
                    
                    if (fallingPerson) {
                        // Accelerate downward (gravity)
                        fallingPerson.userData.velY -= 0.015;
                        fallingPerson.position.y += fallingPerson.userData.velY;
                        
                        // Tumble while falling
                        fallingPerson.rotation.x += 0.1;
                        fallingPerson.rotation.z += 0.05;
                        
                        // Hit the ground
                        if (fallingPerson.position.y <= 0.3) {
                            fallingPerson.position.y = 0.3;
                            
                            // Create fallen body on ground
                            createFallenBody(fallingPerson.position.x, fallingPerson.position.z);
                            
                            // Remove falling person
                            scene.remove(fallingPerson);
                            fallingPerson = null;
                            
                            fallState = 'onGround';
                            fallEventTimer = 0;
                            
                            notify('üò± Someone fell! Ambulance dispatched!', 3000);
                            
                            // Dispatch ambulance
                            dispatchAmbulanceForFallen();
                        }
                    }
                    break;
                    
                case 'onGround':
                    // Body lies on ground, waiting for ambulance
                    if (ambulanceForFallen) {
                        const amb = ambulanceForFallen;
                        const dx = fallenBody.position.x - amb.position.x;
                        const dz = fallenBody.position.z - amb.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist > 3) {
                            // Drive toward body
                            const speed = 0.15;
                            amb.position.x += (dx / dist) * speed;
                            amb.position.z += (dz / dist) * speed;
                            amb.rotation.y = Math.atan2(dx, dz);
                        } else {
                            // Arrived - pick up body
                            fallState = 'pickedup';
                            fallEventTimer = 0;
                            
                            // Hide body
                            if (fallenBody) {
                                scene.remove(fallenBody);
                                fallenBody = null;
                            }
                        }
                    }
                    break;
                    
                case 'pickedup':
                    // Ambulance drives away
                    if (ambulanceForFallen) {
                        const amb = ambulanceForFallen;
                        // Drive toward edge of city
                        amb.position.x += 0.15;
                        amb.rotation.y = 0;
                        
                        if (amb.position.x > halfSize + 20) {
                            // Remove ambulance, reset state
                            scene.remove(ambulanceForFallen);
                            // Remove from cars array
                            const idx = cars.indexOf(ambulanceForFallen);
                            if (idx > -1) cars.splice(idx, 1);
                            const evIdx = emergencyVehicles.indexOf(ambulanceForFallen);
                            if (evIdx > -1) emergencyVehicles.splice(evIdx, 1);
                            ambulanceForFallen = null;
                            
                            fallState = 'none';
                            fallEventTimer = 0;
                            
                            // Respawn a regular ambulance
                            const newAmb = mkCar(0xffffff);
                            newAmb.userData.isEmergency = true;
                            newAmb.userData.emergencyType = 'ambulance';
                            addEmergencyLights(newAmb, 0xff0000, 0xffffff);
                            placeCarOnRoad(newAmb);
                            emergencyVehicles.push(newAmb);
                            cars.push(newAmb);
                            scene.add(newAmb);
                        }
                    }
                    break;
            }
        }
        
        function startFallEvent(t) {
            // Pick a random tall building
            const tallBuildings = buildings.filter(b => b.userData.height > 30);
            if (tallBuildings.length === 0) return;
            
            const building = tallBuildings[Math.floor(Math.random() * tallBuildings.length)];
            const h = building.userData.height;
            
            // Create a flashing window on the building
            const windowHeight = 5 + Math.floor(Math.random() * ((h - 10) / 3.5)) * 3.5;
            
            // Create bright flashing window mesh
            flashingWindow = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 2),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            
            // Position at window on side of building
            const side = Math.floor(Math.random() * 4);
            let px = building.position.x;
            let pz = building.position.z;
            let winX = px, winZ = pz;
            
            if (side === 0) {
                winZ = pz + 4.01;
                flashingWindow.rotation.y = 0;
            } else if (side === 1) {
                winZ = pz - 4.01;
                flashingWindow.rotation.y = Math.PI;
            } else if (side === 2) {
                winX = px + 4.01;
                flashingWindow.rotation.y = Math.PI / 2;
            } else {
                winX = px - 4.01;
                flashingWindow.rotation.y = -Math.PI / 2;
            }
            
            flashingWindow.position.set(winX, windowHeight, winZ);
            scene.add(flashingWindow);
            flashCount = 0;
            
            // Create person at the window
            fallingPerson = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.25, 0.8, 8),
                new THREE.MeshStandardMaterial({ color: 0xff6b6b })
            );
            body.position.y = 0.4;
            fallingPerson.add(body);
            
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.18, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0xffcc99 })
            );
            head.position.y = 0.95;
            fallingPerson.add(head);
            
            // Arms waving
            const armMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
            const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.1), armMat);
            leftArm.position.set(0.3, 0.6, 0);
            leftArm.rotation.z = -0.5;
            fallingPerson.add(leftArm);
            
            const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.1), armMat);
            rightArm.position.set(-0.3, 0.6, 0);
            rightArm.rotation.z = 0.5;
            fallingPerson.add(rightArm);
            
            // Position person slightly in front of window
            let personX = px, personZ = pz;
            if (side === 0) personZ = pz + 4.5;
            else if (side === 1) personZ = pz - 4.5;
            else if (side === 2) personX = px + 4.5;
            else personX = px - 4.5;
            
            fallingPerson.position.set(personX, windowHeight, personZ);
            fallingPerson.userData.velY = 0;
            fallingPerson.userData.groundX = personX;
            fallingPerson.userData.groundZ = personZ;
            
            // Face outward from building
            if (side === 0) fallingPerson.rotation.y = 0;
            else if (side === 1) fallingPerson.rotation.y = Math.PI;
            else if (side === 2) fallingPerson.rotation.y = Math.PI / 2;
            else fallingPerson.rotation.y = -Math.PI / 2;
            
            scene.add(fallingPerson);
            
            fallState = 'inWindow';
            fallEventTimer = 0;
            
            notify('üò∞ Someone is at the window ledge!', 2000);
        }
        
        function createFallenBody(x, z) {
            fallenBody = new THREE.Group();
            
            // Body lying flat
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.25, 0.5),
                new THREE.MeshStandardMaterial({ color: 0xff6b6b })
            );
            body.position.y = 0.15;
            fallenBody.add(body);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0xffcc99 })
            );
            head.position.set(0.5, 0.15, 0);
            fallenBody.add(head);
            
            // Arms spread
            const armMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
            const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), armMat);
            leftArm.position.set(0, 0.15, 0.35);
            fallenBody.add(leftArm);
            
            const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), armMat);
            rightArm.position.set(0, 0.15, -0.35);
            fallenBody.add(rightArm);
            
            fallenBody.position.set(x, 0, z);
            scene.add(fallenBody);
        }
        
        function dispatchAmbulanceForFallen() {
            // Create dedicated ambulance
            ambulanceForFallen = mkCar(0xffffff);
            ambulanceForFallen.userData.isEmergency = true;
            ambulanceForFallen.userData.emergencyType = 'ambulance';
            addEmergencyLights(ambulanceForFallen, 0xff0000, 0xffffff);
            
            // Start from edge of city
            ambulanceForFallen.position.set(-halfSize - 15, 0, fallenBody.position.z);
            ambulanceForFallen.userData.axis = 'x';
            ambulanceForFallen.userData.dir = 1;
            ambulanceForFallen.userData.spd = 0.15;
            
            cars.push(ambulanceForFallen);
            emergencyVehicles.push(ambulanceForFallen);
            scene.add(ambulanceForFallen);
        }

        // ============ SPECIAL EVENTS SYSTEM ============
        
        function updSpecialEvents(t) {
            // Check for new event every 30 seconds, with 60 second cooldown between events
            if (t - lastEventCheck > 30 && t > eventCooldown && !specialEvent) {
                lastEventCheck = t;
                if (Math.random() < 0.4) { // 40% chance to trigger event
                    triggerRandomEvent(t);
                }
            }
            
            // Update active event
            if (specialEvent) {
                updateEvent(t);
            }
        }
        
        function triggerRandomEvent(t) {
            const events = ['parade', 'semiTruck', 'iceCreamTruck', 'dogWalker', 'streaker', 'weddingCortege', 'brokenDown'];
            const eventType = events[Math.floor(Math.random() * events.length)];
            
            specialEvent = { type: eventType, startTime: t, entities: [] };
            
            switch(eventType) {
                case 'parade':
                    createParade();
                    notify('üéâ PARADE! A parade is passing through!', 4000);
                    break;
                case 'semiTruck':
                    createSemiTruck();
                    notify('üöõ Wide Load! Semi truck coming through!', 3000);
                    break;
                case 'iceCreamTruck':
                    createIceCreamTruck();
                    notify('üç¶ Ice Cream Truck! Playing music...', 3000);
                    break;
                case 'dogWalker':
                    createDogWalker();
                    notify('üêï Dog Walker! Someone is walking lots of dogs!', 3000);
                    break;
                case 'streaker':
                    createStreaker();
                    notify('üò± STREAKER! Someone is running through the city!', 3000);
                    break;
                case 'weddingCortege':
                    createWeddingCortege();
                    notify('üíí Wedding! Newlyweds passing through!', 3000);
                    break;
                case 'brokenDown':
                    createBrokenDownCar();
                    notify('üîß Breakdown! A car broke down in the road!', 3000);
                    break;
            }
        }
        
        function createParade() {
            const roadIdx = Math.floor(Math.random() * (GRID.gridCount + 1));
            const roadPos = -halfSize + roadIdx * GRID.cellSize;
            const dir = Math.random() > 0.5 ? 1 : -1;
            const startX = dir > 0 ? -halfSize - 20 : halfSize + 20;
            
            // Lead car with speakers
            const leadCar = mkParadeFloat(0xff00ff, 'PARADE');
            leadCar.position.set(startX, 0, roadPos);
            leadCar.userData.axis = 'x';
            leadCar.userData.dir = dir;
            leadCar.userData.spd = 0.04;
            leadCar.rotation.y = dir > 0 ? 0 : Math.PI;
            scene.add(leadCar);
            specialEvent.entities.push(leadCar);
            
            // Marching band float
            const bandFloat = mkParadeFloat(0xffcc00, 'BAND');
            bandFloat.position.set(startX - dir * 8, 0, roadPos);
            bandFloat.userData.axis = 'x';
            bandFloat.userData.dir = dir;
            bandFloat.userData.spd = 0.04;
            bandFloat.rotation.y = dir > 0 ? 0 : Math.PI;
            scene.add(bandFloat);
            specialEvent.entities.push(bandFloat);
            
            // Clown car
            const clownCar = mkClownCar();
            clownCar.position.set(startX - dir * 16, 0, roadPos);
            clownCar.userData.axis = 'x';
            clownCar.userData.dir = dir;
            clownCar.userData.spd = 0.04;
            clownCar.rotation.y = dir > 0 ? 0 : Math.PI;
            scene.add(clownCar);
            specialEvent.entities.push(clownCar);
            
            // Balloon seller
            const balloonSeller = mkBalloonSeller();
            balloonSeller.position.set(startX - dir * 22, 0.15, roadPos + 2);
            balloonSeller.userData.axis = 'x';
            balloonSeller.userData.dir = dir;
            balloonSeller.userData.spd = 0.03;
            scene.add(balloonSeller);
            specialEvent.entities.push(balloonSeller);
        }
        
        function mkParadeFloat(color, text) {
            const g = new THREE.Group();
            
            // Flatbed base
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(5, 0.8, 2.5),
                new THREE.MeshStandardMaterial({ color: color })
            );
            base.position.y = 0.6;
            g.add(base);
            
            // Decorative top
            const top = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1.5, 2),
                new THREE.MeshStandardMaterial({ color: 0xffffff })
            );
            top.position.y = 1.8;
            g.add(top);
            
            // Streamers/decorations
            for (let i = 0; i < 6; i++) {
                const streamer = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 1, 0.1),
                    new THREE.MeshBasicMaterial({ color: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff][i] })
                );
                streamer.position.set(-2 + i * 0.8, 2.8, 0);
                g.add(streamer);
            }
            
            // Wheels
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[-1.8, 0.3, 1.3], [-1.8, 0.3, -1.3], [1.8, 0.3, 1.3], [1.8, 0.3, -1.3]].forEach(p => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.3, 12), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...p);
                g.add(wheel);
            });
            
            return g;
        }
        
        function mkClownCar() {
            const g = new THREE.Group();
            
            // Tiny colorful car
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2, 1, 1.2),
                new THREE.MeshStandardMaterial({ color: 0xff6600 })
            );
            body.position.y = 0.6;
            g.add(body);
            
            // Polka dots
            for (let i = 0; i < 5; i++) {
                const dot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15),
                    new THREE.MeshBasicMaterial({ color: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff][i] })
                );
                dot.position.set(-0.6 + i * 0.3, 0.8, 0.61);
                g.add(dot);
            }
            
            // Big red nose on front
            const nose = new THREE.Mesh(
                new THREE.SphereGeometry(0.3),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            nose.position.set(1.1, 0.6, 0);
            g.add(nose);
            
            // Clown heads popping out
            for (let i = 0; i < 3; i++) {
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2),
                    new THREE.MeshStandardMaterial({ color: 0xffcc99 })
                );
                head.position.set(-0.5 + i * 0.5, 1.3, 0);
                g.add(head);
                
                // Colorful hair
                const hair = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15),
                    new THREE.MeshBasicMaterial({ color: [0xff0000, 0x00ff00, 0x0000ff][i] })
                );
                hair.position.set(-0.5 + i * 0.5, 1.5, 0);
                g.add(hair);
            }
            
            // Wheels
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[0.7, 0.25, 0.6], [0.7, 0.25, -0.6], [-0.7, 0.25, 0.6], [-0.7, 0.25, -0.6]].forEach(p => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.15, 12), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...p);
                g.add(wheel);
            });
            
            return g;
        }
        
        function mkBalloonSeller() {
            const g = new THREE.Group();
            
            // Person
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.25, 0.8, 8),
                new THREE.MeshStandardMaterial({ color: 0x3366cc })
            );
            body.position.y = 0.5;
            g.add(body);
            
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.18),
                new THREE.MeshStandardMaterial({ color: 0xffcc99 })
            );
            head.position.y = 1.1;
            g.add(head);
            
            // Bunch of balloons
            const balloonColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff6600];
            for (let i = 0; i < 7; i++) {
                const balloon = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshStandardMaterial({ color: balloonColors[i] })
                );
                const angle = (i / 7) * Math.PI * 2;
                balloon.position.set(Math.cos(angle) * 0.4, 2.2 + Math.sin(i) * 0.3, Math.sin(angle) * 0.4);
                g.add(balloon);
                
                // String
                const string = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.01, 0.01, 1),
                    new THREE.MeshBasicMaterial({ color: 0x888888 })
                );
                string.position.set(Math.cos(angle) * 0.2, 1.5, Math.sin(angle) * 0.2);
                g.add(string);
            }
            
            return g;
        }
        
        function createSemiTruck() {
            const roadIdx = Math.floor(Math.random() * (GRID.gridCount + 1));
            const roadPos = -halfSize + roadIdx * GRID.cellSize;
            const dir = Math.random() > 0.5 ? 1 : -1;
            const startX = dir > 0 ? -halfSize - 30 : halfSize + 30;
            
            const semi = mkSemiTruck();
            semi.position.set(startX, 0, roadPos);
            semi.userData.axis = 'x';
            semi.userData.dir = dir;
            semi.userData.spd = 0.05;
            semi.rotation.y = dir > 0 ? 0 : Math.PI;
            scene.add(semi);
            specialEvent.entities.push(semi);
        }
        
        function mkSemiTruck() {
            const g = new THREE.Group();
            
            // Cab
            const cab = new THREE.Mesh(
                new THREE.BoxGeometry(3, 2.5, 2.2),
                new THREE.MeshStandardMaterial({ color: 0x2244aa })
            );
            cab.position.set(4, 1.5, 0);
            g.add(cab);
            
            // Cab windshield
            const windshield = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 1.2),
                new THREE.MeshBasicMaterial({ color: 0x88ccff })
            );
            windshield.position.set(5.51, 1.8, 0);
            windshield.rotation.y = Math.PI / 2;
            g.add(windshield);
            
            // Trailer
            const trailer = new THREE.Mesh(
                new THREE.BoxGeometry(10, 3.5, 2.4),
                new THREE.MeshStandardMaterial({ color: 0xcccccc })
            );
            trailer.position.set(-2.5, 2, 0);
            g.add(trailer);
            
            // "WIDE LOAD" sign
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.5, 0.1),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            );
            sign.position.set(-7.5, 2, 0);
            sign.rotation.y = -Math.PI / 2;
            g.add(sign);
            
            // Wheels (10 total)
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            // Cab wheels
            [[3.5, 0.5, 1.2], [3.5, 0.5, -1.2], [5, 0.5, 1.2], [5, 0.5, -1.2]].forEach(p => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.4, 12), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...p);
                g.add(wheel);
            });
            // Trailer wheels
            [[-5, 0.5, 1.2], [-5, 0.5, -1.2], [-6.5, 0.5, 1.2], [-6.5, 0.5, -1.2], [-4, 0.5, 1.2], [-4, 0.5, -1.2]].forEach(p => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.4, 12), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...p);
                g.add(wheel);
            });
            
            return g;
        }
        
        function createIceCreamTruck() {
            const roadIdx = Math.floor(Math.random() * (GRID.gridCount + 1));
            const roadPos = -halfSize + roadIdx * GRID.cellSize;
            const dir = Math.random() > 0.5 ? 1 : -1;
            const startX = dir > 0 ? -halfSize - 10 : halfSize + 10;
            
            const truck = mkIceCreamTruck();
            truck.position.set(startX, 0, roadPos + 1.5); // On sidewalk side
            truck.userData.axis = 'x';
            truck.userData.dir = dir;
            truck.userData.spd = 0.025; // Very slow, playing music
            truck.userData.isIceCream = true;
            truck.rotation.y = dir > 0 ? 0 : Math.PI;
            scene.add(truck);
            specialEvent.entities.push(truck);
        }
        
        function mkIceCreamTruck() {
            const g = new THREE.Group();
            
            // White van body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(3.5, 2, 1.8),
                new THREE.MeshStandardMaterial({ color: 0xffffff })
            );
            body.position.y = 1.2;
            g.add(body);
            
            // Pink/blue stripes
            const stripe1 = new THREE.Mesh(
                new THREE.BoxGeometry(3.6, 0.3, 0.05),
                new THREE.MeshBasicMaterial({ color: 0xff88cc })
            );
            stripe1.position.set(0, 1.5, 0.93);
            g.add(stripe1);
            
            const stripe2 = new THREE.Mesh(
                new THREE.BoxGeometry(3.6, 0.3, 0.05),
                new THREE.MeshBasicMaterial({ color: 0x88ccff })
            );
            stripe2.position.set(0, 1.1, 0.93);
            g.add(stripe2);
            
            // Ice cream cone on top
            const cone = new THREE.Mesh(
                new THREE.ConeGeometry(0.4, 0.8, 8),
                new THREE.MeshStandardMaterial({ color: 0xddaa66 })
            );
            cone.position.set(0, 2.6, 0);
            cone.rotation.z = Math.PI;
            g.add(cone);
            
            const iceCream = new THREE.Mesh(
                new THREE.SphereGeometry(0.35),
                new THREE.MeshStandardMaterial({ color: 0xffcccc })
            );
            iceCream.position.set(0, 2.9, 0);
            g.add(iceCream);
            
            // Music notes (floating)
            for (let i = 0; i < 3; i++) {
                const note = new THREE.Mesh(
                    new THREE.SphereGeometry(0.12),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                note.position.set(1 + i * 0.4, 2.5 + Math.sin(i) * 0.3, 0);
                note.userData.musicNote = true;
                note.userData.noteOffset = i;
                g.add(note);
            }
            
            // Wheels
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[1.2, 0.3, 0.9], [1.2, 0.3, -0.9], [-1.2, 0.3, 0.9], [-1.2, 0.3, -0.9]].forEach(p => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.2, 12), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...p);
                g.add(wheel);
            });
            
            return g;
        }
        
        function createDogWalker() {
            const bx = Math.floor(Math.random() * GRID.gridCount);
            const bz = Math.floor(Math.random() * GRID.gridCount);
            const blockCenterX = -halfSize + bx * GRID.cellSize + GRID.cellSize / 2;
            const blockCenterZ = -halfSize + bz * GRID.cellSize + GRID.cellSize / 2;
            const innerSize = GRID.cellSize - GRID.roadWidth;
            
            const walker = mkDogWalker();
            walker.position.set(blockCenterX, 0.15, blockCenterZ - innerSize/2 + 1);
            walker.userData.axis = 'x';
            walker.userData.dir = 1;
            walker.userData.spd = 0.015;
            scene.add(walker);
            specialEvent.entities.push(walker);
        }
        
        function mkDogWalker() {
            const g = new THREE.Group();
            
            // Person
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.18, 0.22, 0.7, 8),
                new THREE.MeshStandardMaterial({ color: 0x66aa66 })
            );
            body.position.y = 0.45;
            g.add(body);
            
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.15),
                new THREE.MeshStandardMaterial({ color: 0xffcc99 })
            );
            head.position.y = 0.95;
            g.add(head);
            
            // 5 dogs on leashes
            const dogColors = [0x8b4513, 0xffffff, 0x000000, 0xd2691e, 0x808080];
            for (let i = 0; i < 5; i++) {
                const dog = new THREE.Group();
                
                const dogBody = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.2, 0.15),
                    new THREE.MeshStandardMaterial({ color: dogColors[i] })
                );
                dogBody.position.y = 0.15;
                dog.add(dogBody);
                
                const dogHead = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1),
                    new THREE.MeshStandardMaterial({ color: dogColors[i] })
                );
                dogHead.position.set(0.2, 0.2, 0);
                dog.add(dogHead);
                
                // Leash
                const leash = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.01, 0.01, 1.2),
                    new THREE.MeshBasicMaterial({ color: 0x444444 })
                );
                leash.position.set(0, 0.5, 0);
                leash.rotation.z = Math.PI / 4;
                dog.add(leash);
                
                const angle = (i - 2) * 0.4;
                dog.position.set(1 + Math.abs(i - 2) * 0.3, 0, angle);
                dog.userData.dogIndex = i;
                g.add(dog);
            }
            
            return g;
        }
        
        function createStreaker() {
            const roadIdx = Math.floor(Math.random() * (GRID.gridCount + 1));
            const roadPos = -halfSize + roadIdx * GRID.cellSize;
            const dir = Math.random() > 0.5 ? 1 : -1;
            const startZ = dir > 0 ? -halfSize - 5 : halfSize + 5;
            
            const streaker = mkStreaker();
            streaker.position.set(roadPos, 0.15, startZ);
            streaker.userData.axis = 'z';
            streaker.userData.dir = dir;
            streaker.userData.spd = 0.12; // Running fast!
            streaker.rotation.y = dir > 0 ? Math.PI / 2 : -Math.PI / 2;
            scene.add(streaker);
            specialEvent.entities.push(streaker);
        }
        
        function mkStreaker() {
            const g = new THREE.Group();
            
            // Just a running figure (wearing shorts for decency!)
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.18, 0.6, 8),
                new THREE.MeshStandardMaterial({ color: 0xffcc99 }) // Skin color
            );
            body.position.y = 0.5;
            g.add(body);
            
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.14),
                new THREE.MeshStandardMaterial({ color: 0xffcc99 })
            );
            head.position.y = 0.95;
            g.add(head);
            
            // Shorts (for decency)
            const shorts = new THREE.Mesh(
                new THREE.CylinderGeometry(0.19, 0.19, 0.2, 8),
                new THREE.MeshStandardMaterial({ color: 0xff0000 })
            );
            shorts.position.y = 0.25;
            g.add(shorts);
            
            // Arms out wide
            const armMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
            const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.08, 0.08), armMat);
            leftArm.position.set(0, 0.6, 0.3);
            leftArm.rotation.x = 0.5;
            g.add(leftArm);
            
            const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.08, 0.08), armMat);
            rightArm.position.set(0, 0.6, -0.3);
            rightArm.rotation.x = -0.5;
            g.add(rightArm);
            
            return g;
        }
        
        function createWeddingCortege() {
            const roadIdx = Math.floor(Math.random() * (GRID.gridCount + 1));
            const roadPos = -halfSize + roadIdx * GRID.cellSize;
            const dir = Math.random() > 0.5 ? 1 : -1;
            const startX = dir > 0 ? -halfSize - 15 : halfSize + 15;
            
            // Lead limo
            const limo = mkWeddingLimo();
            limo.position.set(startX, 0, roadPos + 1.5);
            limo.userData.axis = 'x';
            limo.userData.dir = dir;
            limo.userData.spd = 0.06;
            limo.rotation.y = dir > 0 ? 0 : Math.PI;
            scene.add(limo);
            specialEvent.entities.push(limo);
            
            // Following cars with ribbons
            for (let i = 0; i < 3; i++) {
                const car = mkWeddingCar();
                car.position.set(startX - dir * (6 + i * 5), 0, roadPos + 1.5);
                car.userData.axis = 'x';
                car.userData.dir = dir;
                car.userData.spd = 0.06;
                car.rotation.y = dir > 0 ? 0 : Math.PI;
                scene.add(car);
                specialEvent.entities.push(car);
            }
        }
        
        function mkWeddingLimo() {
            const g = new THREE.Group();
            
            // Long white limo body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(5, 0.8, 1.4),
                new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.8, roughness: 0.2 })
            );
            body.position.y = 0.6;
            g.add(body);
            
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(4.5, 0.5, 1.3),
                new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.8, roughness: 0.2 })
            );
            roof.position.y = 1.15;
            g.add(roof);
            
            // "JUST MARRIED" sign
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 0.4, 0.05),
                new THREE.MeshBasicMaterial({ color: 0xff88cc })
            );
            sign.position.set(-2.5, 0.8, 0);
            sign.rotation.y = -Math.PI / 2;
            g.add(sign);
            
            // Ribbons
            for (let i = 0; i < 4; i++) {
                const ribbon = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.05, 0.05),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                ribbon.position.set(-2.6 - i * 0.3, 0.6 - i * 0.1, (i % 2 === 0 ? 0.5 : -0.5));
                g.add(ribbon);
            }
            
            // Flowers on hood
            const flowers = new THREE.Mesh(
                new THREE.SphereGeometry(0.3),
                new THREE.MeshStandardMaterial({ color: 0xff6699 })
            );
            flowers.position.set(2.2, 1.1, 0);
            g.add(flowers);
            
            // Wheels
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[2, 0.25, 0.7], [2, 0.25, -0.7], [-2, 0.25, 0.7], [-2, 0.25, -0.7]].forEach(p => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.15, 12), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...p);
                g.add(wheel);
            });
            
            return g;
        }
        
        function mkWeddingCar() {
            const g = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 0.6, 1.2),
                new THREE.MeshStandardMaterial({ color: 0xcccccc })
            );
            body.position.y = 0.5;
            g.add(body);
            
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 0.4, 1.1),
                new THREE.MeshStandardMaterial({ color: 0xcccccc })
            );
            roof.position.y = 0.9;
            g.add(roof);
            
            // Ribbon on antenna
            const antenna = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.8),
                new THREE.MeshBasicMaterial({ color: 0x444444 })
            );
            antenna.position.set(-0.8, 1.3, 0.4);
            g.add(antenna);
            
            const ribbon = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.15, 0.02),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            ribbon.position.set(-0.8, 1.7, 0.4);
            g.add(ribbon);
            
            // Wheels
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[0.7, 0.2, 0.6], [0.7, 0.2, -0.6], [-0.7, 0.2, 0.6], [-0.7, 0.2, -0.6]].forEach(p => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.12, 12), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...p);
                g.add(wheel);
            });
            
            return g;
        }
        
        function createBrokenDownCar() {
            const roadIdx = Math.floor(Math.random() * (GRID.gridCount + 1));
            const roadPos = -halfSize + roadIdx * GRID.cellSize;
            const posX = -halfSize + Math.random() * totalSize;
            
            const car = mkBrokenCar();
            car.position.set(posX, 0, roadPos + 1.5);
            car.userData.isBrokenDown = true;
            car.rotation.y = Math.random() > 0.5 ? 0.1 : -0.1; // Slightly askew
            scene.add(car);
            specialEvent.entities.push(car);
        }
        
        function mkBrokenCar() {
            const g = new THREE.Group();
            
            // Car body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 0.55, 1.1),
                new THREE.MeshStandardMaterial({ color: 0x886644 }) // Rusty color
            );
            body.position.y = 0.38;
            g.add(body);
            
            const cab = new THREE.Mesh(
                new THREE.BoxGeometry(1.1, 0.45, 1),
                new THREE.MeshStandardMaterial({ color: 0x333344 })
            );
            cab.position.set(-0.2, 0.78, 0);
            g.add(cab);
            
            // Open hood
            const hood = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.05, 1),
                new THREE.MeshStandardMaterial({ color: 0x886644 })
            );
            hood.position.set(1.2, 1, 0);
            hood.rotation.z = -0.8;
            g.add(hood);
            
            // Steam/smoke coming out
            for (let i = 0; i < 4; i++) {
                const steam = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15 + i * 0.08),
                    new THREE.MeshBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.6 - i * 0.1 })
                );
                steam.position.set(0.9, 1 + i * 0.3, 0);
                steam.userData.steamCloud = true;
                steam.userData.steamIndex = i;
                g.add(steam);
            }
            
            // Frustrated person next to car
            const person = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.18, 0.6, 8),
                new THREE.MeshStandardMaterial({ color: 0x3366cc })
            );
            person.position.set(1.5, 0.4, 0.8);
            g.add(person);
            
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.12),
                new THREE.MeshStandardMaterial({ color: 0xffcc99 })
            );
            head.position.set(1.5, 0.85, 0.8);
            g.add(head);
            
            // Hazard triangles
            const triangle = new THREE.Mesh(
                new THREE.ConeGeometry(0.2, 0.4, 3),
                new THREE.MeshBasicMaterial({ color: 0xff6600 })
            );
            triangle.position.set(-2, 0.2, 0);
            triangle.rotation.z = Math.PI;
            g.add(triangle);
            
            // Wheels
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[0.6, 0.18, 0.5], [0.6, 0.18, -0.5], [-0.6, 0.18, 0.5], [-0.6, 0.18, -0.5]].forEach(p => {
                const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 0.12, 12), wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(...p);
                g.add(wheel);
            });
            
            return g;
        }
        
        function updateEvent(t) {
            const elapsed = t - specialEvent.startTime;
            
            // Move entities
            specialEvent.entities.forEach(entity => {
                if (entity.userData.isBrokenDown) {
                    // Animate steam
                    entity.traverse(child => {
                        if (child.userData.steamCloud) {
                            child.position.y = 1 + child.userData.steamIndex * 0.3 + Math.sin(t * 3 + child.userData.steamIndex) * 0.1;
                        }
                    });
                    return;
                }
                
                // Animate music notes on ice cream truck
                if (entity.userData.isIceCream) {
                    entity.traverse(child => {
                        if (child.userData.musicNote) {
                            child.position.y = 2.5 + Math.sin(t * 5 + child.userData.noteOffset * 2) * 0.3;
                        }
                    });
                }
                
                if (entity.userData.spd) {
                    // Check for pedestrians before moving
                    let entityBlocked = false;
                    for (const ped of peds) {
                        if (!ped.visible) continue;
                        const pdx = ped.position.x - entity.position.x;
                        const pdz = ped.position.z - entity.position.z;
                        
                        if (entity.userData.axis === 'x') {
                            const ahead = pdx * entity.userData.dir;
                            const lateral = Math.abs(pdz);
                            if (ahead > 0 && ahead < 4 && lateral < 2) {
                                entityBlocked = true;
                                break;
                            }
                        } else {
                            const ahead = pdz * entity.userData.dir;
                            const lateral = Math.abs(pdx);
                            if (ahead > 0 && ahead < 4 && lateral < 2) {
                                entityBlocked = true;
                                break;
                            }
                        }
                    }
                    
                    if (!entityBlocked) {
                        if (entity.userData.axis === 'x') {
                            entity.position.x += entity.userData.spd * entity.userData.dir;
                        } else {
                            entity.position.z += entity.userData.spd * entity.userData.dir;
                        }
                    }
                }
            });
            
            // Check if event should end
            let allGone = true;
            specialEvent.entities.forEach(entity => {
                if (entity.userData.isBrokenDown) {
                    if (elapsed < 45) allGone = false; // Broken car stays 45 seconds
                } else {
                    const pos = entity.userData.axis === 'x' ? entity.position.x : entity.position.z;
                    if (pos > -halfSize - 40 && pos < halfSize + 40) {
                        allGone = false;
                    }
                }
            });
            
            if (allGone || elapsed > 60) {
                endEvent();
            }
        }
        
        function endEvent() {
            // Remove all event entities
            specialEvent.entities.forEach(entity => {
                scene.remove(entity);
            });
            
            eventCooldown = specialEvent.startTime + 90; // 90 second cooldown
            specialEvent = null;
        }

        function mkSecrets() {
            const ufo = mkUFO();
            ufo.position.set(30, 65, 30);
            ufo.userData.secret = 'üõ∏ UFO';
            ufo.userData.type = 'ufo';
            secrets.push(ufo);
            scene.add(ufo);
            
            const balloon = mkBalloon();
            balloon.position.set(5, 50, -30);
            balloon.userData.secret = 'üéà Hot Air Balloon';
            balloon.userData.type = 'balloon';
            secrets.push(balloon);
            scene.add(balloon);
            
            const heli = mkHelicopter();
            heli.position.set(-30, 55, -25);
            heli.userData.secret = 'üöÅ Helicopter';
            heli.userData.type = 'heli';
            secrets.push(heli);
            scene.add(heli);
        }

        function mkUFO() {
            const g = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(4, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2),
                new THREE.MeshStandardMaterial({ color: 0xaabbcc, metalness: 0.9, roughness: 0.1 })
            );
            body.scale.y = 0.25;
            g.add(body);
            
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(5, 0.5, 16, 32),
                new THREE.MeshStandardMaterial({ color: 0x8899aa, metalness: 0.8 })
            );
            ring.rotation.x = Math.PI / 2;
            g.add(ring);
            
            const dome = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 32, 16),
                new THREE.MeshStandardMaterial({ color: 0x88ffff, transparent: true, opacity: 0.6 })
            );
            dome.position.y = 0.8;
            g.add(dome);
            
            for (let i = 0; i < 8; i++) {
                const a = (i / 8) * Math.PI * 2;
                const lt = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
                lt.position.set(Math.cos(a) * 5, 0, Math.sin(a) * 5);
                lt.userData.ufoL = true;
                lt.userData.ph = i;
                g.add(lt);
            }
            return g;
        }

        function mkBalloon() {
            const g = new THREE.Group();
            const balloon = new THREE.Mesh(
                new THREE.SphereGeometry(5, 24, 24),
                new THREE.MeshStandardMaterial({ color: 0xff4444 })
            );
            balloon.scale.y = 1.3;
            g.add(balloon);
            
            const basket = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 1.5, 2.5),
                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            basket.position.y = -9;
            g.add(basket);
            
            const ropeMat = new THREE.MeshBasicMaterial({ color: 0x8b4513 });
            [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([x, z]) => {
                const rope = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 6), ropeMat);
                rope.position.set(x, -5.5, z);
                g.add(rope);
            });
            return g;
        }

        function mkHelicopter() {
            const g = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(1.2, 1.5, 4, 8),
                new THREE.MeshStandardMaterial({ color: 0xff3333 })
            );
            body.rotation.z = Math.PI / 2;
            g.add(body);
            
            const rotor = new THREE.Group();
            for (let i = 0; i < 4; i++) {
                const blade = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 0.05, 0.4),
                    new THREE.MeshStandardMaterial({ color: 0x444444 })
                );
                blade.rotation.y = (i / 4) * Math.PI;
                rotor.add(blade);
            }
            rotor.position.y = 1.5;
            g.add(rotor);
            g.userData.mainRotor = rotor;
            
            return g;
        }

        function updRain() {
            if (!rain) return;
            const p = rain.geometry.attributes.position.array, v = rain.geometry.attributes.velocity.array;
            for (let i = 0; i < p.length / 3; i++) {
                p[i * 3 + 1] -= v[i];
                // Add wind effect
                p[i * 3] += windDirection.x * windStrength * 0.1;
                p[i * 3 + 2] += windDirection.z * windStrength * 0.1;
                if (p[i * 3 + 1] < 0) { 
                    p[i * 3 + 1] = 100; 
                    p[i * 3] = cam.position.x + (Math.random() - 0.5) * 200; 
                    p[i * 3 + 2] = cam.position.z + (Math.random() - 0.5) * 200; 
                }
            }
            rain.geometry.attributes.position.needsUpdate = true;
        }
        
        function updWeather(t) {
            weatherTimer += 0.016;
            
            // Random weather changes
            if (weatherTimer > nextWeatherChange) {
                changeWeather();
                weatherTimer = 0;
            }
            
            // Update storm effects
            if (weatherState === 'storm') {
                // Lightning flashes
                if (t - lastLightning > 3 + Math.random() * 8) {
                    triggerLightning();
                    lastLightning = t;
                }
                
                // Update flying debris
                updStormDebris(t);
            }
            
            // Update weather indicator
            updateWeatherUI();
        }
        
        function changeWeather() {
            const oldWeather = weatherState;
            
            // Weather transition probabilities (mostly sunny)
            const rand = Math.random();
            if (weatherState === 'sunny') {
                if (rand < 0.7) weatherState = 'sunny'; // 70% stay sunny
                else if (rand < 0.9) weatherState = 'cloudy'; // 20% become cloudy
                else weatherState = 'rain'; // 10% sudden rain
            } else if (weatherState === 'cloudy') {
                if (rand < 0.4) weatherState = 'sunny'; // 40% clear up
                else if (rand < 0.7) weatherState = 'cloudy'; // 30% stay cloudy
                else if (rand < 0.9) weatherState = 'rain'; // 20% rain
                else weatherState = 'storm'; // 10% storm
            } else if (weatherState === 'rain') {
                if (rand < 0.3) weatherState = 'sunny'; // 30% clear up
                else if (rand < 0.5) weatherState = 'cloudy'; // 20% become cloudy
                else if (rand < 0.8) weatherState = 'rain'; // 30% stay rainy
                else weatherState = 'storm'; // 20% storm
            } else if (weatherState === 'storm') {
                if (rand < 0.5) weatherState = 'rain'; // 50% become rain
                else if (rand < 0.8) weatherState = 'cloudy'; // 30% become cloudy
                else weatherState = 'storm'; // 20% stay stormy
            }
            
            // Set next weather change time
            if (weatherState === 'sunny') {
                nextWeatherChange = 45 + Math.random() * 90; // Sunny lasts longer
            } else if (weatherState === 'storm') {
                nextWeatherChange = 15 + Math.random() * 30; // Storms are shorter
            } else {
                nextWeatherChange = 20 + Math.random() * 40;
            }
            
            // Apply weather effects
            if (oldWeather !== weatherState) {
                applyWeatherEffects();
                
                // Notify
                const weatherNames = {
                    'sunny': '‚òÄÔ∏è Clear skies',
                    'cloudy': '‚òÅÔ∏è Cloudy',
                    'rain': 'üåßÔ∏è Rain starting',
                    'storm': '‚õàÔ∏è STORM WARNING!'
                };
                notify(weatherNames[weatherState], 2500);
            }
        }
        
        function applyWeatherEffects() {
            // Clear existing effects
            if (rain) { scene.remove(rain); rain = null; }
            clearStormDebris();
            
            // Set wind
            windDirection = { x: Math.random() - 0.5, z: Math.random() - 0.5 };
            const windLen = Math.sqrt(windDirection.x ** 2 + windDirection.z ** 2);
            if (windLen > 0) {
                windDirection.x /= windLen;
                windDirection.z /= windLen;
            }
            
            switch (weatherState) {
                case 'sunny':
                    scene.background = new THREE.Color(0x87CEEB);
                    scene.fog = new THREE.Fog(0x87CEEB, 80, 350);
                    windStrength = 0;
                    raining = false;
                    break;
                    
                case 'cloudy':
                    scene.background = new THREE.Color(0x9cacbc);
                    scene.fog = new THREE.Fog(0x9cacbc, 60, 250);
                    windStrength = 0.5;
                    raining = false;
                    break;
                    
                case 'rain':
                    scene.background = new THREE.Color(0x778899);
                    scene.fog = new THREE.Fog(0x778899, 30, 150);
                    windStrength = 1;
                    createRain(6000);
                    raining = true;
                    break;
                    
                case 'storm':
                    scene.background = new THREE.Color(0x4a5568);
                    scene.fog = new THREE.Fog(0x4a5568, 20, 100);
                    windStrength = 3;
                    createRain(12000);
                    raining = true;
                    createStormDebris();
                    break;
            }
        }
        
        function createRain(particleCount) {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(particleCount * 3);
            const vel = new Float32Array(particleCount);
            for (let i = 0; i < particleCount; i++) {
                pos[i * 3] = cam.position.x + (Math.random() - 0.5) * 200;
                pos[i * 3 + 1] = Math.random() * 100;
                pos[i * 3 + 2] = cam.position.z + (Math.random() - 0.5) * 200;
                vel[i] = 0.5 + Math.random() * 0.5;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('velocity', new THREE.BufferAttribute(vel, 1));
            
            const rainColor = weatherState === 'storm' ? 0x6688aa : 0x9999aa;
            const rainSize = weatherState === 'storm' ? 0.15 : 0.1;
            rain = new THREE.Points(geo, new THREE.PointsMaterial({ 
                color: rainColor, 
                size: rainSize, 
                transparent: true, 
                opacity: 0.6 
            }));
            scene.add(rain);
        }
        
        function createStormDebris() {
            // Flying newspapers, leaves, trash
            const debrisTypes = [
                { color: 0xeeeeee, size: [0.4, 0.3, 0.01], name: 'paper' },  // Newspaper
                { color: 0x558833, size: [0.15, 0.15, 0.02], name: 'leaf' }, // Leaf
                { color: 0xcccccc, size: [0.2, 0.2, 0.2], name: 'bag' },     // Plastic bag
                { color: 0x884422, size: [0.3, 0.2, 0.01], name: 'cardboard' } // Cardboard
            ];
            
            for (let i = 0; i < 25; i++) {
                const type = debrisTypes[Math.floor(Math.random() * debrisTypes.length)];
                const debris = new THREE.Mesh(
                    new THREE.BoxGeometry(...type.size),
                    new THREE.MeshStandardMaterial({ 
                        color: type.color, 
                        side: THREE.DoubleSide,
                        transparent: type.name === 'bag',
                        opacity: type.name === 'bag' ? 0.7 : 1
                    })
                );
                
                debris.position.set(
                    (Math.random() - 0.5) * 100,
                    1 + Math.random() * 20,
                    (Math.random() - 0.5) * 100
                );
                
                debris.userData.velocity = {
                    x: (Math.random() - 0.5) * 0.3 + windDirection.x * windStrength * 0.2,
                    y: (Math.random() - 0.5) * 0.1,
                    z: (Math.random() - 0.5) * 0.3 + windDirection.z * windStrength * 0.2
                };
                debris.userData.rotSpeed = {
                    x: (Math.random() - 0.5) * 0.2,
                    y: (Math.random() - 0.5) * 0.2,
                    z: (Math.random() - 0.5) * 0.2
                };
                debris.userData.type = type.name;
                
                stormDebris.push(debris);
                scene.add(debris);
            }
        }
        
        function clearStormDebris() {
            stormDebris.forEach(d => scene.remove(d));
            stormDebris = [];
        }
        
        function updStormDebris(t) {
            stormDebris.forEach(debris => {
                // Move with wind
                debris.position.x += debris.userData.velocity.x + windDirection.x * windStrength * 0.05;
                debris.position.y += debris.userData.velocity.y + Math.sin(t * 3 + debris.position.x) * 0.02;
                debris.position.z += debris.userData.velocity.z + windDirection.z * windStrength * 0.05;
                
                // Tumble
                debris.rotation.x += debris.userData.rotSpeed.x;
                debris.rotation.y += debris.userData.rotSpeed.y;
                debris.rotation.z += debris.userData.rotSpeed.z;
                
                // Wrap around
                if (debris.position.x > halfSize + 20) debris.position.x = -halfSize - 20;
                if (debris.position.x < -halfSize - 20) debris.position.x = halfSize + 20;
                if (debris.position.z > halfSize + 20) debris.position.z = -halfSize - 20;
                if (debris.position.z < -halfSize - 20) debris.position.z = halfSize + 20;
                
                // Keep above ground, below certain height
                if (debris.position.y < 0.5) {
                    debris.position.y = 0.5;
                    debris.userData.velocity.y = Math.abs(debris.userData.velocity.y) * 0.8;
                }
                if (debris.position.y > 30) {
                    debris.position.y = 30;
                    debris.userData.velocity.y = -Math.abs(debris.userData.velocity.y);
                }
            });
        }
        
        function triggerLightning() {
            // Flash the scene
            const originalBg = scene.background.clone();
            scene.background = new THREE.Color(0xffffff);
            
            setTimeout(() => {
                scene.background = new THREE.Color(0x4a5568);
            }, 50);
            
            setTimeout(() => {
                scene.background = new THREE.Color(0xcccccc);
            }, 100);
            
            setTimeout(() => {
                scene.background = new THREE.Color(0x4a5568);
            }, 150);
        }
        
        function updateWeatherUI() {
            const weatherEl = $('weather');
            if (weatherEl) {
                const icons = { 'sunny': '‚òÄÔ∏è', 'cloudy': '‚òÅÔ∏è', 'rain': 'üåßÔ∏è', 'storm': '‚õàÔ∏è' };
                weatherEl.textContent = icons[weatherState] || '‚òÄÔ∏è';
            }
        }

        function setupMM() { 
            const c = $('mm'); 
            c.width = 130; 
            c.height = 130; 
            mmCtx = c.getContext('2d'); 
        }

        function updMM() {
            if (!mmCtx) return;
            mmCtx.fillStyle = 'rgba(200,230,255,0.95)'; 
            mmCtx.fillRect(0, 0, 130, 130);
            
            const scale = 0.55;
            
            mmCtx.strokeStyle = '#555';
            mmCtx.lineWidth = 3;
            for (let i = 0; i <= GRID.gridCount; i++) {
                const pos = (-halfSize + i * GRID.cellSize - cam.position.x) * scale + 65;
                const posZ = (-halfSize + i * GRID.cellSize - cam.position.z) * scale + 65;
                mmCtx.beginPath(); mmCtx.moveTo(pos, 0); mmCtx.lineTo(pos, 130); mmCtx.stroke();
                mmCtx.beginPath(); mmCtx.moveTo(0, posZ); mmCtx.lineTo(130, posZ); mmCtx.stroke();
            }
            
            mmCtx.fillStyle = 'rgba(100,120,140,0.6)';
            buildings.forEach(b => { 
                const x = 65 + (b.position.x - cam.position.x) * scale;
                const y = 65 + (b.position.z - cam.position.z) * scale;
                if (x > -10 && x < 140 && y > -10 && y < 140) mmCtx.fillRect(x - 4, y - 4, 8, 8); 
            });
            
            mmCtx.fillStyle = '#e44';
            cars.forEach(c => { 
                if (!c.userData.isEmergency) {
                    const x = 65 + (c.position.x - cam.position.x) * scale;
                    const y = 65 + (c.position.z - cam.position.z) * scale;
                    if (x > 0 && x < 130 && y > 0 && y < 130) mmCtx.fillRect(x - 2, y - 2, 4, 4);
                }
            });
            
            // Emergency vehicles in blue
            mmCtx.fillStyle = '#00f';
            emergencyVehicles.forEach(c => { 
                const x = 65 + (c.position.x - cam.position.x) * scale;
                const y = 65 + (c.position.z - cam.position.z) * scale;
                if (x > 0 && x < 130 && y > 0 && y < 130) mmCtx.fillRect(x - 3, y - 3, 6, 6);
            });
            
            // Bicycles in yellow
            mmCtx.fillStyle = '#ff0';
            bicycles.forEach(b => { 
                const x = 65 + (b.position.x - cam.position.x) * scale;
                const y = 65 + (b.position.z - cam.position.z) * scale;
                if (x > 0 && x < 130 && y > 0 && y < 130) {
                    mmCtx.beginPath();
                    mmCtx.arc(x, y, 3, 0, Math.PI * 2);
                    mmCtx.fill();
                }
            });
            
            // Omnibus in green
            if (omnibus) {
                mmCtx.fillStyle = '#22aa22';
                const x = 65 + (omnibus.position.x - cam.position.x) * scale;
                const y = 65 + (omnibus.position.z - cam.position.z) * scale;
                if (x > 0 && x < 130 && y > 0 && y < 130) {
                    mmCtx.fillRect(x - 4, y - 3, 8, 6);
                }
                
                // Bus stops as small green circles
                mmCtx.strokeStyle = '#22aa22';
                mmCtx.lineWidth = 1;
                omnibusStops.forEach(stop => {
                    const sx = 65 + (stop.x - cam.position.x) * scale;
                    const sy = 65 + (stop.z - cam.position.z) * scale;
                    if (sx > 0 && sx < 130 && sy > 0 && sy < 130) {
                        mmCtx.beginPath();
                        mmCtx.arc(sx, sy, 4, 0, Math.PI * 2);
                        mmCtx.stroke();
                    }
                });
            }
            
            mmCtx.fillStyle = '#0088ff'; 
            mmCtx.beginPath(); 
            mmCtx.arc(65, 65, 5, 0, Math.PI * 2); 
            mmCtx.fill();
            mmCtx.strokeStyle = '#0066cc'; 
            mmCtx.lineWidth = 2; 
            mmCtx.beginPath(); 
            mmCtx.moveTo(65, 65); 
            mmCtx.lineTo(65 + Math.sin(yaw) * 14, 65 - Math.cos(yaw) * 14); 
            mmCtx.stroke();
        }

        function setupInput() {
            addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.code === 'KeyR') {
                    // Cycle through weather states manually
                    const states = ['sunny', 'cloudy', 'rain', 'storm'];
                    const currentIndex = states.indexOf(weatherState);
                    weatherState = states[(currentIndex + 1) % states.length];
                    applyWeatherEffects();
                    const weatherNames = {
                        'sunny': '‚òÄÔ∏è Clear skies',
                        'cloudy': '‚òÅÔ∏è Cloudy',
                        'rain': 'üåßÔ∏è Rainy',
                        'storm': '‚õàÔ∏è STORM!'
                    };
                    notify(weatherNames[weatherState], 2000);
                    weatherTimer = 0; // Reset timer
                }
                if (e.code === 'Space') boost = true;
            });
            addEventListener('keyup', e => { keys[e.code] = false; if (e.code === 'Space') boost = false; });
            addEventListener('mousemove', e => { 
                if (document.pointerLockElement) { 
                    yaw -= e.movementX * 0.002; 
                    pitch -= e.movementY * 0.002; 
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch)); 
                } 
            });
            $('c').addEventListener('click', () => $('c').requestPointerLock());
            addEventListener('wheel', e => { cam.fov = Math.max(20, Math.min(100, cam.fov + e.deltaY * 0.05)); cam.updateProjectionMatrix(); });
            addEventListener('resize', () => { cam.aspect = innerWidth / innerHeight; cam.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
        }

        function notify(txt, dur = 3000) { 
            const n = $('notif'); n.innerHTML = txt; n.classList.add('show'); 
            setTimeout(() => n.classList.remove('show'), dur); 
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta(), t = clock.getElapsedTime();
            
            const spd = boost ? baseSpd * 3 : baseSpd;
            const fwd = new THREE.Vector3(Math.sin(yaw) * Math.cos(pitch), Math.sin(pitch), Math.cos(yaw) * Math.cos(pitch));
            const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
            
            if (keys['KeyW'] || keys['ArrowUp']) vel.add(fwd.clone().multiplyScalar(spd * 0.12));
            if (keys['KeyS'] || keys['ArrowDown']) vel.add(fwd.clone().multiplyScalar(-spd * 0.12));
            if (keys['KeyA'] || keys['ArrowLeft']) vel.add(right.clone().multiplyScalar(-spd * 0.12));
            if (keys['KeyD'] || keys['ArrowRight']) vel.add(right.clone().multiplyScalar(spd * 0.12));
            if (keys['KeyQ']) vel.y -= spd * 0.12;
            if (keys['KeyE']) vel.y += spd * 0.12;
            vel.multiplyScalar(0.9);
            cam.position.add(vel);
            
            // Minimum altitude of 2 meters
            if (cam.position.y < 2) cam.position.y = 2;
            
            cam.rotation.order = 'YXZ'; cam.rotation.y = yaw; cam.rotation.x = pitch;
            
            $('alt').textContent = Math.round(cam.position.y);
            $('spd').textContent = Math.round(vel.length() * 100);
            $('pos').textContent = `${Math.round(cam.position.x)},${Math.round(cam.position.z)}`;
            
            updCars(t); 
            updPeds(t); 
            updBicycles(t);
            updOmnibus(t);
            updSpecialEvents(t);
            updGarbageTruck(t);
            updFallingPerson(t);
            updTL(t); 
            updSecrets(t);
            updBillboards(t);
            updWindowLights(t);
            updEmergencyLights(t);
            updGridlock(t);
            updWeather(t);
            chkDiscoveries();
            if (raining) updRain();
            updMM();
            
            renderer.render(scene, cam);
        }

        function updCars(t) {
            const carLength = 2.5;
            const safeDistance = carLength * 5; // 5 car lengths for emergency vehicles
            
            cars.forEach(car => {
                let shouldStop = false;
                
                // Check traffic lights (emergency vehicles ignore)
                if (!car.userData.isEmergency) {
                    tlights.forEach(tl => {
                        const ix = tl.userData.intersection.x;
                        const iz = tl.userData.intersection.z;
                        const phase = (t + tl.userData.phase) % 10;
                        const isRedForX = phase < 5;
                        
                        if (car.userData.axis === 'x') {
                            const dist = (ix - car.position.x) * car.userData.dir;
                            if (dist > 0 && dist < 8 && Math.abs(car.position.z - iz) < 5) {
                                if (isRedForX) shouldStop = true;
                            }
                        } else {
                            const dist = (iz - car.position.z) * car.userData.dir;
                            if (dist > 0 && dist < 8 && Math.abs(car.position.x - ix) < 5) {
                                if (!isRedForX) shouldStop = true;
                            }
                        }
                    });
                }
                
                // Check for pedestrians on the road
                peds.forEach(ped => {
                    if (!ped.visible) return;

                    const dx = ped.position.x - car.position.x;
                    const dz = ped.position.z - car.position.z;

                    if (car.userData.axis === 'x') {
                        const ahead = dx * car.userData.dir;
                        const inPath = Math.abs(dz) < 3;
                        if (ahead > 0 && ahead < 8 && inPath) {
                            shouldStop = true;
                        }
                    } else {
                        const ahead = dz * car.userData.dir;
                        const inPath = Math.abs(dx) < 3;
                        if (ahead > 0 && ahead < 8 && inPath) {
                            shouldStop = true;
                        }
                    }
                });
                
                // Check for emergency vehicles - only yield if they're behind you and approaching
                if (!car.userData.isEmergency) {
                    emergencyVehicles.forEach(ev => {
                        if (ev.userData.axis !== car.userData.axis) return; // Different roads, ignore
                        
                        const dx = ev.position.x - car.position.x;
                        const dz = ev.position.z - car.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        // Only yield if emergency vehicle is behind us and within range
                        if (dist < safeDistance) {
                            if (car.userData.axis === 'x') {
                                // Emergency vehicle behind us (opposite of our direction)
                                const evBehind = dx * car.userData.dir < 0;
                                const sameLane = Math.abs(dz) < 3;
                                // Emergency vehicle approaching (moving toward us)
                                const evApproaching = ev.userData.dir === car.userData.dir;
                                if (evBehind && sameLane && evApproaching) {
                                    // Pull over - don't stop, just slow down and let them pass
                                    // Actually for simplicity, just don't block - keep moving
                                }
                            } else {
                                const evBehind = dz * car.userData.dir < 0;
                                const sameLane = Math.abs(dx) < 3;
                                const evApproaching = ev.userData.dir === car.userData.dir;
                                if (evBehind && sameLane && evApproaching) {
                                    // Keep moving, don't block
                                }
                            }
                        }
                    });
                }
                
                // Check for cars directly ahead in SAME lane - only stop if very close
                cars.forEach(other => {
                    if (other === car) return;
                    const dx = other.position.x - car.position.x;
                    const dz = other.position.z - car.position.z;
                    
                    if (car.userData.axis === 'x') {
                        const ahead = dx * car.userData.dir;
                        const sameLane = Math.abs(other.position.z - car.position.z) < 1.5;
                        if (ahead > 0 && ahead < 4 && sameLane) {
                            shouldStop = true;
                        }
                    } else {
                        const ahead = dz * car.userData.dir;
                        const sameLane = Math.abs(other.position.x - car.position.x) < 1.5;
                        if (ahead > 0 && ahead < 4 && sameLane) {
                            shouldStop = true;
                        }
                    }
                });
                
                // Check for broken down cars or other obstacles from special events
                let obstacleAhead = false;
                if (specialEvent && specialEvent.entities) {
                    specialEvent.entities.forEach(entity => {
                        if (!entity.userData.isBrokenDown) return;
                        const dx = entity.position.x - car.position.x;
                        const dz = entity.position.z - car.position.z;
                        
                        if (car.userData.axis === 'x') {
                            const ahead = dx * car.userData.dir;
                            const nearLane = Math.abs(entity.position.z - car.position.z) < 3;
                            if (ahead > 0 && ahead < 8 && nearLane) {
                                obstacleAhead = true;
                            }
                        } else {
                            const ahead = dz * car.userData.dir;
                            const nearLane = Math.abs(entity.position.x - car.position.x) < 3;
                            if (ahead > 0 && ahead < 8 && nearLane) {
                                obstacleAhead = true;
                            }
                        }
                    });
                }
                
                // Check for garbage truck
                if (garbageTruck && garbageTruckActive) {
                    const dx = garbageTruck.position.x - car.position.x;
                    const dz = garbageTruck.position.z - car.position.z;
                    
                    if (car.userData.axis === 'x') {
                        const ahead = dx * car.userData.dir;
                        const nearLane = Math.abs(dz) < 3;
                        if (ahead > 0 && ahead < 10 && nearLane) {
                            obstacleAhead = true;
                        }
                    } else {
                        const ahead = dz * car.userData.dir;
                        const nearLane = Math.abs(dx) < 3;
                        if (ahead > 0 && ahead < 10 && nearLane) {
                            obstacleAhead = true;
                        }
                    }
                }
                
                // Check for omnibus
                if (omnibus) {
                    const dx = omnibus.position.x - car.position.x;
                    const dz = omnibus.position.z - car.position.z;
                    
                    if (car.userData.axis === 'x') {
                        const ahead = dx * car.userData.dir;
                        const nearLane = Math.abs(dz) < 3;
                        if (ahead > 0 && ahead < 6 && nearLane) {
                            obstacleAhead = true;
                        }
                    } else {
                        const ahead = dz * car.userData.dir;
                        const nearLane = Math.abs(dx) < 3;
                        if (ahead > 0 && ahead < 6 && nearLane) {
                            obstacleAhead = true;
                        }
                    }
                }
                
                // Move car if not stopped
                if (!shouldStop && !obstacleAhead) {
                    const speed = car.userData.isEmergency ? car.userData.spd * 1.5 : car.userData.spd;
                    
                    if (car.userData.axis === 'x') {
                        car.position.x += speed * car.userData.dir;
                        car.position.z = car.userData.roadPos + car.userData.laneOffset;
                        if (car.position.x > halfSize + 15) car.position.x = -halfSize - 15;
                        if (car.position.x < -halfSize - 15) car.position.x = halfSize + 15;
                    } else {
                        car.position.z += speed * car.userData.dir;
                        car.position.x = car.userData.roadPos + car.userData.laneOffset;
                        if (car.position.z > halfSize + 15) car.position.z = -halfSize - 15;
                        if (car.position.z < -halfSize - 15) car.position.z = halfSize + 15;
                    }
                } else if (obstacleAhead || shouldStop) {
                    // Try to change lanes to go around obstacle
                    const oppositeOffset = -car.userData.laneOffset;
                    
                    // Check if opposite lane is clear
                    let oppositeClear = true;
                    cars.forEach(other => {
                        if (other === car) return;
                        const dx = other.position.x - car.position.x;
                        const dz = other.position.z - car.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < 8) {
                            if (car.userData.axis === 'x' && Math.abs(other.position.z - (car.userData.roadPos + oppositeOffset)) < 1.5) {
                                oppositeClear = false;
                            } else if (car.userData.axis === 'z' && Math.abs(other.position.x - (car.userData.roadPos + oppositeOffset)) < 1.5) {
                                oppositeClear = false;
                            }
                        }
                    });
                    
                    // Also check for oncoming traffic
                    cars.forEach(other => {
                        if (other === car) return;
                        if (other.userData.axis !== car.userData.axis) return;
                        if (other.userData.dir === car.userData.dir) return; // Same direction, ok
                        
                        const dx = other.position.x - car.position.x;
                        const dz = other.position.z - car.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < 15) {
                            // Oncoming car nearby, don't switch
                            oppositeClear = false;
                        }
                    });
                    
                    if (oppositeClear && obstacleAhead) {
                        // Switch lanes to go around
                        car.userData.laneOffset = oppositeOffset;
                        const speed = car.userData.spd * 0.8;
                        
                        if (car.userData.axis === 'x') {
                            car.position.x += speed * car.userData.dir;
                            car.position.z = car.userData.roadPos + oppositeOffset;
                        } else {
                            car.position.z += speed * car.userData.dir;
                            car.position.x = car.userData.roadPos + oppositeOffset;
                        }
                        car.userData.stuckTime = 0;
                    } else if (car.userData.isEmergency) {
                        // Emergency vehicles try to go around obstacles by switching lanes
                        // But NEVER if there are pedestrians crossing nearby
                        let pedCrossing = false;
                        peds.forEach(ped => {
                            if (ped.userData.state === 'crossing') {
                                const dx = ped.position.x - car.position.x;
                                const dz = ped.position.z - car.position.z;
                                const dist = Math.sqrt(dx * dx + dz * dz);
                                if (dist < 10) pedCrossing = true;
                            }
                        });
                        
                        if (pedCrossing) return; // Don't move if pedestrian crossing nearby
                        
                        const speed = car.userData.spd * 1.2;
                        const emergencyOppositeOffset = -car.userData.laneOffset;
                        
                        // Check if opposite lane is clear of cars
                        let emergencyOppositeClear = true;
                        cars.forEach(other => {
                            if (other === car) return;
                            const dx = other.position.x - car.position.x;
                            const dz = other.position.z - car.position.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            if (dist < 6) {
                                if (car.userData.axis === 'x' && Math.abs(other.position.z - (car.userData.roadPos + emergencyOppositeOffset)) < 1.5) {
                                    emergencyOppositeClear = false;
                                } else if (car.userData.axis === 'z' && Math.abs(other.position.x - (car.userData.roadPos + emergencyOppositeOffset)) < 1.5) {
                                    emergencyOppositeClear = false;
                                }
                            }
                        });
                        
                        if (emergencyOppositeClear) {
                            if (car.userData.axis === 'x') {
                                car.position.x += speed * car.userData.dir;
                                car.position.z = car.userData.roadPos + emergencyOppositeOffset;
                                if (car.position.x > halfSize + 15) car.position.x = -halfSize - 15;
                                if (car.position.x < -halfSize - 15) car.position.x = halfSize + 15;
                            } else {
                                car.position.z += speed * car.userData.dir;
                                car.position.x = car.userData.roadPos + emergencyOppositeOffset;
                                if (car.position.z > halfSize + 15) car.position.z = -halfSize - 15;
                                if (car.position.z < -halfSize - 15) car.position.z = halfSize + 15;
                            }
                            car.userData.stuckTime = 0;
                        }
                    } else {
                        // Regular car stuck - try to self-unstick after 5 seconds
                        if (car.userData.stuckTime > 5) {
                            // Force unstick by reversing (and getting in proper lane) or switching lanes temporarily
                            if (Math.random() < 0.5) {
                                car.userData.dir *= -1;
                                // Update lane for new direction (right-side driving)
                                if (car.userData.axis === 'x') {
                                    car.userData.laneOffset = car.userData.dir * 1.8;
                                    car.rotation.y = car.userData.dir > 0 ? 0 : Math.PI;
                                } else {
                                    car.userData.laneOffset = -car.userData.dir * 1.8;
                                    car.rotation.y = car.userData.dir > 0 ? -Math.PI / 2 : Math.PI / 2;
                                }
                            } else {
                                // Temporarily use opposite lane to pass obstacle
                                car.userData.laneOffset = -car.userData.laneOffset;
                            }
                            car.userData.stuckTime = 0;
                        }
                    }
                }
            });
        }

        function updEmergencyLights(t) {
            emergencyVehicles.forEach(ev => {
                ev.traverse(child => {
                    if (child.userData.emergencyLight) {
                        const flash = Math.sin(t * 15) > 0;
                        child.material.color.setHex(flash ? child.userData.lightColor : 0x333333);
                    }
                });
            });
        }
        
        function updGridlock(t) {
            // Check every second
            if (t - lastGridlockCheck < 1) return;
            lastGridlockCheck = t;
            
            // Update stuck time for all cars
            cars.forEach(car => {
                if (!car.userData.lastPos) {
                    car.userData.lastPos = { x: car.position.x, z: car.position.z };
                    car.userData.stuckTime = 0;
                    return;
                }
                
                const dx = car.position.x - car.userData.lastPos.x;
                const dz = car.position.z - car.userData.lastPos.z;
                const moved = Math.sqrt(dx * dx + dz * dz);
                
                if (moved < 0.5) {
                    // Car hasn't moved much
                    car.userData.stuckTime = (car.userData.stuckTime || 0) + 1;
                } else {
                    car.userData.stuckTime = 0;
                    car.userData.beingHelped = false;
                }
                
                car.userData.lastPos = { x: car.position.x, z: car.position.z };
            });
            
            // Find a stuck car that needs help (stuck > 10 seconds)
            if (!trafficCop && !trafficCopTarget) {
                const stuckCar = cars.find(c => 
                    c.userData.stuckTime > 10 && 
                    !c.userData.beingHelped && 
                    !c.userData.isEmergency
                );
                
                if (stuckCar) {
                    // Dispatch traffic cop!
                    stuckCar.userData.beingHelped = true;
                    trafficCopTarget = stuckCar;
                    spawnTrafficCop(stuckCar);
                    notify('üöî Traffic cop dispatched to clear gridlock!', 2500);
                }
            }
            
            // Update traffic cop
            if (trafficCop && trafficCopTarget) {
                const dx = trafficCopTarget.position.x - trafficCop.position.x;
                const dz = trafficCopTarget.position.z - trafficCop.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < 3) {
                    // Arrived at gridlock - clear it!
                    clearGridlock(trafficCopTarget);
                    
                    // Cop walks away
                    trafficCop.userData.state = 'leaving';
                    trafficCop.userData.leaveTimer = 0;
                } else if (trafficCop.userData.state === 'approaching') {
                    // Walk toward stuck car
                    const speed = 0.08;
                    trafficCop.position.x += (dx / dist) * speed;
                    trafficCop.position.z += (dz / dist) * speed;
                    trafficCop.rotation.y = Math.atan2(dx, dz);
                    
                    // Animate walking
                    trafficCop.userData.walk = (trafficCop.userData.walk || 0) + 0.2;
                    const sw = Math.sin(trafficCop.userData.walk) * 0.4;
                    if (trafficCop.userData.ll) trafficCop.userData.ll.rotation.x = sw;
                    if (trafficCop.userData.rl) trafficCop.userData.rl.rotation.x = -sw;
                }
                
                if (trafficCop.userData.state === 'leaving') {
                    trafficCop.userData.leaveTimer += 0.016;
                    
                    // Walk to edge of road
                    trafficCop.position.x += 0.05;
                    trafficCop.rotation.y = Math.PI / 2;
                    
                    trafficCop.userData.walk = (trafficCop.userData.walk || 0) + 0.2;
                    const sw = Math.sin(trafficCop.userData.walk) * 0.4;
                    if (trafficCop.userData.ll) trafficCop.userData.ll.rotation.x = sw;
                    if (trafficCop.userData.rl) trafficCop.userData.rl.rotation.x = -sw;
                    
                    if (trafficCop.userData.leaveTimer > 3) {
                        // Remove cop
                        scene.remove(trafficCop);
                        trafficCop = null;
                        trafficCopTarget = null;
                    }
                }
            }
        }
        
        function spawnTrafficCop(targetCar) {
            const cop = new THREE.Group();
            
            // Blue police uniform
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.18, 0.6, 8),
                new THREE.MeshStandardMaterial({ color: 0x000066 })
            );
            body.position.y = 0.45;
            cop.add(body);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0xffcc99 })
            );
            head.position.y = 0.85;
            cop.add(head);
            
            // Police cap
            const cap = new THREE.Mesh(
                new THREE.CylinderGeometry(0.14, 0.14, 0.08, 8),
                new THREE.MeshStandardMaterial({ color: 0x000044 })
            );
            cap.position.y = 0.95;
            cop.add(cap);
            
            // Cap brim
            const brim = new THREE.Mesh(
                new THREE.CylinderGeometry(0.16, 0.16, 0.02, 8),
                new THREE.MeshStandardMaterial({ color: 0x000033 })
            );
            brim.position.set(0.05, 0.92, 0);
            cop.add(brim);
            
            // Legs
            const legMat = new THREE.MeshStandardMaterial({ color: 0x000044 });
            const ll = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.35, 6), legMat);
            ll.position.set(0.07, 0.17, 0);
            cop.add(ll);
            cop.userData.ll = ll;
            
            const rl = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.35, 6), legMat);
            rl.position.set(-0.07, 0.17, 0);
            cop.add(rl);
            cop.userData.rl = rl;
            
            // Whistle (small yellow sphere)
            const whistle = new THREE.Mesh(
                new THREE.SphereGeometry(0.03, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            );
            whistle.position.set(0.15, 0.7, 0.1);
            cop.add(whistle);
            
            // Position cop near the stuck car
            const offset = 8;
            cop.position.set(
                targetCar.position.x - offset,
                0,
                targetCar.position.z + (Math.random() - 0.5) * 4
            );
            
            cop.userData.state = 'approaching';
            cop.userData.walk = 0;
            
            trafficCop = cop;
            scene.add(cop);
        }
        
        function clearGridlock(stuckCar) {
            // Force all nearby stuck cars to move
            const clearRadius = 15;
            
            cars.forEach(car => {
                const dx = car.position.x - stuckCar.position.x;
                const dz = car.position.z - stuckCar.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < clearRadius && car.userData.stuckTime > 5) {
                    // Unstick this car by reversing direction or switching lanes
                    if (Math.random() < 0.5) {
                        // Reverse direction
                        car.userData.dir *= -1;
                        if (car.userData.axis === 'x') {
                            car.rotation.y = car.userData.dir > 0 ? 0 : Math.PI;
                        } else {
                            car.rotation.y = car.userData.dir > 0 ? -Math.PI / 2 : Math.PI / 2;
                        }
                    } else {
                        // Switch lanes
                        car.userData.laneOffset = -car.userData.laneOffset;
                    }
                    
                    // Give it a little push
                    if (car.userData.axis === 'x') {
                        car.position.x += car.userData.dir * 2;
                    } else {
                        car.position.z += car.userData.dir * 2;
                    }
                    
                    car.userData.stuckTime = 0;
                    car.userData.beingHelped = false;
                }
            });
            
            notify('üöó Traffic cleared!', 2000);
        }

        function updPeds(t) {
            peds.forEach((p, idx) => {
                if (!p.userData.target) {
                    setNewPedTarget(p);
                    return;
                }
                
                // Skip pedestrians on the bus
                if (p.userData.state === 'onBus') {
                    return;
                }
                
                // Handle waiting at bus stop
                if (p.userData.state === 'waitingForBus') {
                    // Just stand there waiting
                    return;
                }
                
                // Handle walking to bus stop
                if (p.userData.state === 'toBusStop') {
                    const to = p.userData.target.clone().sub(p.position);
                    to.y = 0;
                    const d = to.length();
                    
                    if (d < 0.5) {
                        // Arrived at bus stop, wait
                        p.userData.state = 'waitingForBus';
                    } else {
                        const dir = to.normalize();
                        p.position.x += dir.x * p.userData.spd;
                        p.position.z += dir.z * p.userData.spd;
                        p.rotation.y = Math.atan2(dir.x, dir.z);
                        
                        p.userData.walk += 0.15;
                        const sw = Math.sin(p.userData.walk) * 0.3;
                        if (p.userData.ll) p.userData.ll.rotation.x = sw;
                        if (p.userData.rl) p.userData.rl.rotation.x = -sw;
                    }
                    return;
                }
                
                // Handle being inside building
                if (p.userData.state === 'insideBuilding') {
                    p.userData.insideTime = (p.userData.insideTime || 0) + 0.016;
                    if (p.userData.insideTime > 3 + Math.random() * 5) {
                        // Exit building through the same door
                        if (p.userData.targetEntrance) {
                            // Position at the door
                            p.position.set(p.userData.targetEntrance.x, 0.15, p.userData.targetEntrance.z);
                            
                            // Move slightly away from door based on door facing
                            const entrance = p.userData.targetEntrance;
                            if (entrance.side === 0) p.position.z += 1.5;
                            else if (entrance.side === 1) p.position.z -= 1.5;
                            else if (entrance.side === 2) p.position.x += 1.5;
                            else p.position.x -= 1.5;
                        }
                        p.visible = true;
                        p.userData.state = 'exitingBuilding';
                        p.userData.insideTime = 0;
                        
                        // Set target to nearby sidewalk
                        const bx = p.userData.currentBlock.x;
                        const bz = p.userData.currentBlock.z;
                        const blockCenterX = -halfSize + bx * GRID.cellSize + GRID.cellSize / 2;
                        const blockCenterZ = -halfSize + bz * GRID.cellSize + GRID.cellSize / 2;
                        const innerSize = GRID.cellSize - GRID.roadWidth;
                        const swOffset = GRID.sidewalkWidth / 2;
                        
                        // Walk to nearest sidewalk edge
                        const side = Math.floor(Math.random() * 4);
                        if (side === 0) p.userData.target = new THREE.Vector3(blockCenterX, 0.15, blockCenterZ - innerSize/2 + swOffset);
                        else if (side === 1) p.userData.target = new THREE.Vector3(blockCenterX, 0.15, blockCenterZ + innerSize/2 - swOffset);
                        else if (side === 2) p.userData.target = new THREE.Vector3(blockCenterX - innerSize/2 + swOffset, 0.15, blockCenterZ);
                        else p.userData.target = new THREE.Vector3(blockCenterX + innerSize/2 - swOffset, 0.15, blockCenterZ);
                    }
                    return;
                }
                
                // Handle exiting building - walk to sidewalk then resume normal walking
                if (p.userData.state === 'exitingBuilding') {
                    const to = p.userData.target.clone().sub(p.position);
                    to.y = 0;
                    const d = to.length();
                    
                    if (d < 0.5) {
                        p.userData.state = 'walking';
                        p.userData.targetEntrance = null;
                        setNewPedTarget(p);
                    } else {
                        const dir = to.normalize();
                        p.position.x += dir.x * p.userData.spd;
                        p.position.z += dir.z * p.userData.spd;
                        p.rotation.y = Math.atan2(dir.x, dir.z);
                        
                        p.userData.walk += 0.15;
                        const sw = Math.sin(p.userData.walk) * 0.3;
                        if (p.userData.ll) p.userData.ll.rotation.x = sw;
                        if (p.userData.rl) p.userData.rl.rotation.x = -sw;
                    }
                    return;
                }
                
                const to = p.userData.target.clone().sub(p.position);
                to.y = 0;
                const d = to.length();
                
                if (d < 0.5) {
                    if (p.userData.state === 'toBuilding') {
                        // Arrived at building entrance - go inside
                        p.visible = false;
                        p.userData.state = 'insideBuilding';
                        p.userData.insideTime = 0;
                        return;
                    } else if (p.userData.state === 'towardsCrosswalk') {
                        const cw = p.userData.pendingCrosswalk;
                        if (isSafeToCross(cw)) {
                            p.userData.state = 'crossing';
                            if (cw.axis === 'z') {
                                const crossDir = p.userData.pendingBlock.z > p.userData.currentBlock.z ? 1 : -1;
                                p.userData.target = new THREE.Vector3(cw.x, 0.15, cw.z + crossDir * (GRID.roadWidth - 1));
                            } else {
                                const crossDir = p.userData.pendingBlock.x > p.userData.currentBlock.x ? 1 : -1;
                                p.userData.target = new THREE.Vector3(cw.x + crossDir * (GRID.roadWidth - 1), 0.15, cw.z);
                            }
                        } else {
                            // Not safe - wait briefly then give up if too long
                            p.userData.waitTime = (p.userData.waitTime || 0) + 0.016;
                            if (p.userData.waitTime > 3) {
                                // Give up waiting, go somewhere else
                                p.userData.waitTime = 0;
                                p.userData.state = 'walking';
                                p.userData.pendingCrosswalk = null;
                                p.userData.pendingBlock = null;
                                setNewPedTarget(p);
                            }
                        }
                        return;
                    } else if (p.userData.state === 'crossing') {
                        p.userData.currentBlock = p.userData.pendingBlock;
                        p.userData.state = 'walking';
                        p.userData.pendingCrosswalk = null;
                        p.userData.pendingBlock = null;
                        setNewPedTarget(p);
                    } else {
                        setNewPedTarget(p);
                    }
                } else {
                    // Movement speed - faster when crossing
                    let moveSpeed = p.userData.spd;
                    if (p.userData.state === 'crossing') {
                        moveSpeed = p.userData.spd * 2; // Walk faster across road
                    }
                    
                    // Check for other pedestrians - avoid walking through each other
                    let blocked = false;
                    const targetDir = to.clone().normalize();
                    
                    for (const other of peds) {
                        if (other === p || !other.visible) continue;
                        
                        const dx = other.position.x - p.position.x;
                        const dz = other.position.z - p.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        // Check if other ped is directly ahead
                        if (dist < 0.8) {
                            // Check if we're walking toward them
                            const dot = targetDir.x * dx + targetDir.z * dz;
                            if (dot > 0) {
                                // They're ahead of us, slow down or stop
                                moveSpeed *= 0.2;
                                if (dist < 0.5) blocked = true;
                                break;
                            }
                        }
                    }
                    
                    // Check for vehicles when crossing the road
                    if (p.userData.state === 'crossing' && !blocked) {
                        // Check cars approaching
                        for (const car of cars) {
                            const dx = car.position.x - p.position.x;
                            const dz = car.position.z - p.position.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            
                            // Only block if car is close AND moving toward pedestrian
                            if (dist < 4) {
                                // Check if car is heading toward ped
                                let approaching = false;
                                if (car.userData.axis === 'x') {
                                    approaching = (dx * car.userData.dir < 0) && Math.abs(dz) < 2;
                                } else {
                                    approaching = (dz * car.userData.dir < 0) && Math.abs(dx) < 2;
                                }
                                if (approaching) {
                                    blocked = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (!blocked) {
                        const dir = to.normalize();
                        
                        // Use moveSpeed (faster when crossing)
                        p.position.x += dir.x * moveSpeed;
                        p.position.z += dir.z * moveSpeed;
                        p.rotation.y = Math.atan2(dir.x, dir.z);
                        
                        // Faster leg animation when crossing
                        const walkRate = p.userData.state === 'crossing' ? 0.25 : 0.15;
                        p.userData.walk += walkRate;
                        const sw = Math.sin(p.userData.walk) * 0.3;
                        if (p.userData.ll) p.userData.ll.rotation.x = sw;
                        if (p.userData.rl) p.userData.rl.rotation.x = -sw;
                        
                        p.userData.stuckTime = 0;
                    } else {
                        // Track stuck time
                        p.userData.stuckTime = (p.userData.stuckTime || 0) + 0.016;
                        
                        // If stuck for more than 3 seconds, get a new target
                        if (p.userData.stuckTime > 3) {
                            p.userData.stuckTime = 0;
                            if (p.userData.state === 'crossing') {
                                // Abort crossing, go back
                                p.userData.state = 'walking';
                                p.userData.pendingCrosswalk = null;
                                p.userData.pendingBlock = null;
                            }
                            setNewPedTarget(p);
                        }
                    }
                }
            });
        }

        function isSafeToCross(cw) {
            for (const car of cars) {
                const dx = cw.x - car.position.x;
                const dz = cw.z - car.position.z;
                
                if (cw.axis === 'z' && car.userData.axis === 'x') {
                    if (Math.abs(car.position.z - cw.z) < 5) {
                        const dist = Math.abs(dx);
                        if (dist < 20) return false;
                    }
                } else if (cw.axis === 'x' && car.userData.axis === 'z') {
                    if (Math.abs(car.position.x - cw.x) < 5) {
                        const dist = Math.abs(dz);
                        if (dist < 20) return false;
                    }
                }
            }
            return true;
        }

        function updTL(t) { 
            tlights.forEach(tl => { 
                const ph = (t + tl.userData.phase) % 10;
                // X-axis roads: green from 0-5, red from 5-10
                // Z-axis roads: red from 0-5, green from 5-10
                const xGreen = ph < 4.5;
                const xYellow = ph >= 4.5 && ph < 5;
                const zGreen = ph >= 5 && ph < 9.5;
                const zYellow = ph >= 9.5;
                
                tl.userData.lts.forEach(l => { 
                    const isXAxis = l.userData.axis === 'x';
                    const idx = l.userData.lightIndex; // 0=red, 1=yellow, 2=green
                    
                    let on = false;
                    if (isXAxis) {
                        // Lights for X-axis traffic
                        if (idx === 2) on = xGreen;           // Green
                        else if (idx === 1) on = xYellow;     // Yellow
                        else if (idx === 0) on = !xGreen && !xYellow; // Red
                    } else {
                        // Lights for Z-axis traffic
                        if (idx === 2) on = zGreen;           // Green
                        else if (idx === 1) on = zYellow;     // Yellow  
                        else if (idx === 0) on = !zGreen && !zYellow; // Red
                    }
                    
                    l.material.color.setHex(on ? l.userData.activeCol : 0x222222); 
                }); 
            }); 
        }

        function updBillboards(t) {
            billboards.forEach(bb => {
                bb.traverse(child => {
                    if (child.userData.isBillboardLight) {
                        const idx = child.userData.lightIndex;
                        const wave = Math.sin(t * 3 + idx * 0.5) > 0.3;
                        child.material.opacity = wave ? 1 : 0.2;
                    }
                    if (child.userData.isGlow) {
                        child.material.opacity = 0.3 + Math.sin(t * 2) * 0.2;
                    }
                    // Flash PAY TAXES sign
                    if (child.userData.isTaxSign) {
                        child.visible = Math.sin(t * 4) > 0;
                    }
                    if (child.userData.isTaxSignOff) {
                        child.visible = Math.sin(t * 4) <= 0;
                    }
                });
            });
        }

        function updWindowLights(t) {
            // Toggle multiple windows frequently for visible effect
            if (t >= lastWindowToggle) {
                if (allWindows.length > 0) {
                    // Toggle 5-10 random windows at once
                    const numToToggle = 5 + Math.floor(Math.random() * 6);
                    for (let i = 0; i < numToToggle; i++) {
                        const win = allWindows[Math.floor(Math.random() * allWindows.length)];
                        win.userData.isLit = !win.userData.isLit;
                        win.material.color.setHex(win.userData.isLit ? 0xffeeaa : 0x334455);
                        win.material.needsUpdate = true;
                    }
                }
                // Schedule next toggle 0.5-1.5 seconds from now
                lastWindowToggle = t + 0.5 + Math.random() * 1;
            }
        }

        function updSecrets(t) {
            secrets.forEach(s => {
                if (s.userData.type === 'ufo') { 
                    s.position.x = 30 + Math.sin(t * 0.15) * 25; 
                    s.position.z = 30 + Math.cos(t * 0.2) * 25; 
                    s.position.y = 65 + Math.sin(t * 0.3) * 8;
                    s.rotation.y += 0.01; 
                    s.traverse(c => { if (c.userData.ufoL) c.material.color.setHex(Math.sin(t * 5 + c.userData.ph) > 0 ? 0x00ff00 : 0x004400); }); 
                }
                if (s.userData.type === 'balloon') { 
                    s.position.y = 50 + Math.sin(t * 0.2) * 6; 
                    s.position.x = 5 + Math.sin(t * 0.1) * 10; 
                    s.rotation.y += 0.003; 
                }
                if (s.userData.type === 'heli') { 
                    if (s.userData.mainRotor) s.userData.mainRotor.rotation.y += 0.3;
                }
            });
        }

        function chkDiscoveries() { 
            secrets.forEach(s => { 
                if (cam.position.distanceTo(s.position) < 25 && !discoveries.has(s.userData.secret)) { 
                    discoveries.add(s.userData.secret); 
                    notify(`üéâ DISCOVERED!<br>${s.userData.secret}<br>(${discoveries.size}/3 secrets)`, 4000); 
                } 
            }); 
        }

        init();
    </script>
</body>
</html>
